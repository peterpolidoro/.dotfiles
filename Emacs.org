#+title: Peter Polidoro Emacs Configuration
#+AUTHOR: Peter Polidoro
#+EMAIL: peter@polidoro.io
#+PROPERTY: header-args:emacs-lisp :tangle ./.emacs.d/init.el

* Introduction

This initialization file is based on David Wilson's awesome Emacs configuration: https://github.com/daviwil

This file generates [[file:init.el][init.el]] which will be loaded by Emacs at startup.

#+begin_src emacs-lisp

;; NOTE: init.el is generated from Emacs.org.  Please edit that file
;;       in Emacs and init.el will be generated automatically!

#+end_src

* Setup
** Who am I?

#+begin_src emacs-lisp

(setq user-full-name "Peter Polidoro"
      user-mail-address "peter@polidoro.io")
(setq copyright-names-regexp
      (format "%s <%s>" user-full-name user-mail-address))

#+end_src

** Font Size

#+begin_src emacs-lisp

;; Adjust this font size for each system
(defvar pjp/default-font-size 120)
(defvar pjp/default-variable-font-size 120)

#+end_src

** Frame transparency

#+begin_src emacs-lisp

;; Make frame transparency overridable
(defvar pjp/frame-transparency '(95 . 95))

#+end_src

* Handle Warnings

Package cl is deprecated, remove warning.

#+begin_src emacs-lisp

;;(require 'loadhist)
;;(file-dependents (feature-file 'cl))
(setq byte-compile-warnings '(cl-functions))

#+end_src

* Startup Performance

Make startup faster by reducing the frequency of garbage collection and then
use a hook to measure Emacs startup time.

#+begin_src emacs-lisp

;; The default is 800 kilobytes.  Measured in bytes.
(setq gc-cons-threshold (* 50 1000 1000))

;; Profile emacs startup
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "*** Emacs loaded in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))

#+end_src

* Package Management

Use =Guix= to install package repositories and load =use-package= to
manage package configuration.

** use-package

#+begin_src emacs-lisp

(setq pjp/is-gnu (or (eq system-type 'gnu/linux) (eq system-type 'gnu)))
(setq pjp/is-guix-system (and pjp/is-gnu
                              (require 'f)
                              (string-equal (f-read "/etc/issue")
                                            "\nThis is the GNU system.  Welcome.\n")))

(if pjp/is-gnu
    (setq use-package-always-ensure nil)
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
												   ("melpa-stable" . "https://stable.melpa.org/packages/")
												   ("org" . "https://orgmode.org/elpa/")
												   ("elpa" . "https://elpa.gnu.org/packages/")))
  (package-initialize)
  (unless package-archive-contents
	  (package-refresh-contents))
  (unless (package-installed-p 'use-package)
	  (package-install 'use-package))
  (require 'use-package-ensure)
  (setq use-package-always-ensure t))

(eval-when-compile
  (require 'use-package))
;; (require 'diminish)
(require 'bind-key)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-use-package"

#+end_src

** Guix

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-guix"

"guile"

"guix"

#+end_src

* Keep .emacs.d Clean

I don't want a bunch of transient files showing up as untracked in the Git
repo so I move them all to another location.

#+begin_src emacs-lisp

;; Keep transient cruft out of ~/.emacs.d/
(setq user-emacs-directory "~/.cache/emacs/"
      backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory)))
      url-history-file (expand-file-name "url/history" user-emacs-directory)
      auto-save-list-file-prefix (expand-file-name "auto-save-list/.saves-" user-emacs-directory)
      projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" user-emacs-directory))

;; Use no-littering to automatically set common paths to the new user-emacs-directory
(use-package no-littering)

;; Keep customization settings in a temporary file
(setq custom-file
      (if (boundp 'server-socket-dir)
          (expand-file-name "custom.el" server-socket-dir)
        (expand-file-name (format "emacs-custom-%s.el" (user-uid)) temporary-file-directory)))
(load custom-file t)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-no-littering"

#+end_src

* Update Load Path

I've got a folder of custom Emacs Lisp libraries which must be added to the load path.

#+begin_src emacs-lisp

;; Add my library path to load-path
(push "~/.dotfiles/.emacs.d/lisp" load-path)

#+end_src

* Server Mode

Start the Emacs server from this instance so that all =emacsclient= calls are routed here.

#+begin_src emacs-lisp

;; (server-start)

#+end_src

* Keyboard Bindings
** ESC Cancels All

#+begin_src emacs-lisp

(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+end_src

** Keybinding Panel (which-key)

[[https://github.com/justbur/emacs-which-key][which-key]] is great for getting an overview of what keybindings are available
based on the prefix keys you entered.

#+begin_src emacs-lisp

(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.3))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-which-key"

#+end_src

* General Configuration
** User Interface

*** Clean up Emacs' user interface, make it more minimal.

#+begin_src emacs-lisp

;; Thanks, but no thanks
(setq inhibit-startup-message t)

(scroll-bar-mode -1)        ; Disable visible scrollbar
(tool-bar-mode -1)          ; Disable the toolbar
(tooltip-mode -1)           ; Disable tooltips
(set-fringe-mode 10)        ; Give some breathing room

(menu-bar-mode -1)            ; Disable the menu bar

;; Set up the visible bell
(setq visible-bell t)

#+end_src

*** Improve scrolling.

#+begin_src emacs-lisp

(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1)

#+end_src

*** Set frame transparency and maximize windows by default.

#+begin_src emacs-lisp

(set-frame-parameter (selected-frame) 'alpha pjp/frame-transparency)
(add-to-list 'default-frame-alist `(alpha . ,pjp/frame-transparency))
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))

#+end_src

*** Enable line numbers and customize their format.

#+begin_src emacs-lisp

(column-number-mode)

;; Enable line numbers for some modes
(dolist (mode '(text-mode-hook
                prog-mode-hook
                conf-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 1))))

;; Disable line numbers for some modes
(dolist (mode '(org-mode-hook
                term-mode-hook
                shell-mode-hook
                treemacs-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

*** Don't warn for large files (shows up when launching videos)

#+begin_src emacs-lisp

(setq large-file-warning-threshold nil)

#+end_src

*** Don't warn for following symlinked files

#+begin_src emacs-lisp

(setq vc-follow-symlinks t)

#+end_src

*** Don't warn when advice is added for functions

#+begin_src emacs-lisp

(setq ad-redefinition-action 'accept)

#+end_src

*** Kill whole line

#+BEGIN_SRC emacs-lisp
(setq kill-whole-line t)
#+END_SRC

*** Fill-column

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC

*** Treat camel case as separate words

#+begin_src emacs-lisp

(add-hook 'prog-mode-hook 'subword-mode)

#+end_src

*** Make scripts executable

#+begin_src emacs-lisp

(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

#+end_src

*** Single space after periods

#+begin_src emacs-lisp

(setq sentence-end-double-space nil)

#+end_src

*** Offer to create parent directories on save

#+begin_src emacs-lisp

(add-hook 'before-save-hook
          (lambda ()
            (when buffer-file-name
              (let ((dir (file-name-directory buffer-file-name)))
                (when (and (not (file-exists-p dir))
                           (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                  (make-directory dir t))))))

#+end_src

*** Apply changes to higlighted region

#+begin_src emacs-lisp

(transient-mark-mode t)

#+end_src

*** Overwrite selected text

#+begin_src emacs-lisp

(delete-selection-mode t)

#+end_src

*** Refresh buffers when files change

#+begin_src emacs-lisp

(global-auto-revert-mode t)

#+end_src

*** Yank to point on mouse click

#+begin_src emacs-lisp

(setq mouse-yank-at-point t)

#+end_src

*** Ensure files end with newline

#+begin_src emacs-lisp

(setq require-final-newline t)

#+end_src

*** Shorten yes or no

#+begin_src emacs-lisp

(fset 'yes-or-no-p 'y-or-n-p)

#+end_src

*** Confirm closing Emacs

#+begin_src emacs-lisp

(setq confirm-kill-emacs 'y-or-n-p)

#+end_src

*** Use UTF-8

#+begin_src emacs-lisp

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

#+end_src

*** Use smartparens

#+begin_src emacs-lisp

(use-package smartparens
  :config
  (smartparens-global-mode t)

  (sp-pair "'" nil :actions :rem)
  (sp-pair "`" nil :actions :rem)
  (setq sp-highlight-pair-overlay nil))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-smartparens"

#+end_src

*** Truncate lines

#+begin_src emacs-lisp

(set-default 'truncate-lines t)
(setq truncate-partial-width-windows t)

#+end_src

*** Default tab width

#+begin_src emacs-lisp

(setq-default tab-width 2)

#+end_src

*** Windmove

#+begin_src emacs-lisp

(global-set-key (kbd "s-b")  'windmove-left)
(global-set-key (kbd "s-f") 'windmove-right)
(global-set-key (kbd "s-p")    'windmove-up)
(global-set-key (kbd "s-n")  'windmove-down)

#+end_src

*** Undo-Tree

#+begin_src emacs-lisp

(if pjp/is-gnu
    (use-package undo-tree
      :init
      (global-undo-tree-mode 1)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-undo-tree"

#+end_src

*** Uniquify

#+begin_src emacs-lisp

(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
(setq-default frame-title-format "%b (%f)")

#+end_src

*** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+BEGIN_SRC emacs-lisp

(defun pjp/split-window-below-and-switch ()
  "Split the window horizontally, then switch to the new pane."
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))

(defun pjp/split-window-right-and-switch ()
  "Split the window vertically, then switch to the new pane."
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))

(global-set-key (kbd "C-x 2") 'pjp/split-window-below-and-switch)
(global-set-key (kbd "C-x 3") 'pjp/split-window-right-and-switch)

#+END_SRC

** Theme

#+begin_src emacs-lisp

(load-theme 'euphoria t t)
(enable-theme 'euphoria)
(setq color-theme-is-global t)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

#+end_src

** Font

*** Set the font

Fonts are installed from the "desktop" profile.

#+begin_src emacs-lisp

(when pjp/is-gnu
  (set-face-attribute 'default nil :font "Fira Code Retina" :height pjp/default-font-size)

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height pjp/default-font-size)

  ;; Set the variable pitch face
  ;; (set-face-attribute 'variable-pitch nil :font "Cantarell" :height pjp/default-variable-font-size :weight 'regular)
  (set-face-attribute 'variable-pitch nil :font "Iosevka Aile" :height pjp/default-variable-font-size :weight 'regular))

#+end_src

*** Enable proper Unicode glyph support

#+begin_src emacs-lisp

(defun pjp/replace-unicode-font-mapping (block-name old-font new-font)
  (let* ((block-idx (cl-position-if
                     (lambda (i) (string-equal (car i) block-name))
                     unicode-fonts-block-font-mapping))
         (block-fonts (cadr (nth block-idx unicode-fonts-block-font-mapping)))
         (updated-block (cl-substitute new-font old-font block-fonts :test 'string-equal)))
    (setf (cdr (nth block-idx unicode-fonts-block-font-mapping))
          `(,updated-block))))

(use-package unicode-fonts
  :disabled
  :custom
  (unicode-fonts-skip-font-groups '(low-quality-glyphs))
  :config
  ;; Fix the font mappings to use the right emoji font
  (mapcar
   (lambda (block-name)
     (pjp/replace-unicode-font-mapping block-name "Apple Color Emoji" "Noto Color Emoji"))
   '("Dingbats"
     "Emoticons"
     "Miscellaneous Symbols and Pictographs"
     "Transport and Map Symbols"))
  (unicode-fonts-setup))

#+end_src

*** Emojis in buffers

#+begin_src emacs-lisp

(use-package emojify
  :hook (erc-mode . emojify-mode)
  :commands emojify-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-emojify"

#+end_src

*** All the icons

*NOTE:* The first time you load your configuration on a new machine, you'll need to run `M-x all-the-icons-install-fonts` so that icons display correctly.

#+begin_src emacs-lisp

(use-package all-the-icons)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-all-the-icons"

#+end_src

** Mode Line

*** Doom Mode Line

#+begin_src emacs-lisp

(use-package minions
  :hook (doom-modeline-mode . minions-mode))

(use-package doom-modeline
  :after eshell     ;; Make sure it gets hooked after eshell
  :hook (after-init . doom-modeline-init)
  :custom-face
  (mode-line ((t (:height 0.85))))
  (mode-line-inactive ((t (:height 0.85))))
  :custom
  (doom-modeline-height 15)
  (doom-modeline-bar-width 6)
  (doom-modeline-lsp t)
  (doom-modeline-github nil)
  (doom-modeline-mu4e nil)
  (doom-modeline-irc t)
  (doom-modeline-minor-modes t)
  (doom-modeline-persp-name nil)
  (doom-modeline-buffer-file-name-style 'truncate-except-project)
  (doom-modeline-major-mode-icon nil))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-minions"

"emacs-doom-modeline"

#+end_src

*** Basic Customization

#+begin_src emacs-lisp

(setq display-time-format "%l:%M %p %b %y"
      display-time-default-load-average nil)

#+end_src

*** Enable Mode Diminishing

The [[https://github.com/myrjola/diminish.el][diminish]] package hides pesky minor modes from the modelines.

#+begin_src emacs-lisp

(use-package diminish)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-diminish"

#+end_src

** Notifications

[[https://github.com/jwiegley/alert][alert]] is a great library for showing notifications from other packages in a
variety of ways. For now I just use it to surface desktop notifications from
package code.

#+begin_src emacs-lisp

(use-package alert
  :commands alert
  :config
  (setq alert-default-style 'notifications))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-alert"

#+end_src

** Auto-Saving Changed Files

#+begin_src emacs-lisp :tangle no

(use-package super-save
  :defer 1
  :diminish super-save-mode
  :config
  (super-save-mode +1)
  (setq super-save-auto-save-when-idle t))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

;;"emacs-super-save"

#+end_src

** Auto-Reverting Changed Files

#+begin_src emacs-lisp

(global-auto-revert-mode 1)

#+end_src

** Highlight Matching Braces

#+begin_src emacs-lisp

(use-package paren
  :config
  (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
  (show-paren-mode 1))

#+end_src

** Displaying World Time

=display-time-world= command provides a nice display of the time at a
specified list of timezones. Nice for working in a team with remote members.

#+begin_src emacs-lisp

(setq display-time-world-list
      '(("America/Los_Angeles" "California")
        ("America/New_York" "New York")
        ("Europe/Athens" "Athens")
        ("Pacific/Auckland" "Auckland")
        ("Asia/Shanghai" "Shanghai")))
(setq display-time-world-time-format "%a, %d %b %I:%M %p %Z")

#+end_src

** Pinentry

Emacs can be prompted for the PIN of GPG private keys, we just need to set
=epa-pinentry-mode= to accomplish that:

#+begin_src emacs-lisp

(if pjp/is-gnu
    (setq epa-pinentry-mode 'loopback)
  (pinentry-start))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-pinentry"

"pinentry-emacs"

#+end_src
** TRAMP

#+begin_src emacs-lisp

;; Set default connection mode to SSH
(setq tramp-default-method "ssh")

#+end_src

** Stateful Keymaps with Hydra

#+begin_src emacs-lisp

(use-package hydra
  :defer 1)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-hydra"

#+end_src

*** Bind keys to change text size

#+begin_src emacs-lisp

(defhydra hydra-zoom (global-map "C-=")
  "zoom"
  ("=" text-scale-increase "in")
  ("-" text-scale-decrease "out"))

#+end_src

** Better Completions with Ivy

I currently use Ivy, Counsel, and Swiper to navigate around files, buffers,
and projects super quickly.

#+begin_src emacs-lisp

(use-package ivy
  :diminish
  :bind (("C-s" . swiper))
  :init
  (ivy-mode 1)
  :config
  (setq ivy-use-virtual-buffers t)
  (setq ivy-wrap t)
  (setq ivy-count-format "(%d/%d) ")
  (setq enable-recursive-minibuffers t)

  ;; Use different regex strategies per completion command
  (push '(completion-at-point . ivy--regex-fuzzy) ivy-re-builders-alist) ;; This doesn't seem to work...
  (push '(swiper . ivy--regex-ignore-order) ivy-re-builders-alist)
  (push '(counsel-M-x . ivy--regex-ignore-order) ivy-re-builders-alist)

  ;; Set minibuffer height for different commands
  (setf (alist-get 'counsel-projectile-ag ivy-height-alist) 15)
  (setf (alist-get 'counsel-projectile-rg ivy-height-alist) 15)
  (setf (alist-get 'swiper ivy-height-alist) 15)
  (setf (alist-get 'counsel-switch-buffer ivy-height-alist) 7))

(use-package ivy-hydra
  :defer t
  :after hydra)

(use-package ivy-rich
  :init
  (ivy-rich-mode 1)
  :after counsel
  :config
  (setq ivy-format-function #'ivy-format-function-line)
  (setq ivy-rich-display-transformers-list
        (plist-put ivy-rich-display-transformers-list
                   'ivy-switch-buffer
                   '(:columns
                     ((ivy-rich-candidate (:width 40))
                      (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)); return the buffer indicators
                      (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))          ; return the major mode info
                      (ivy-rich-switch-buffer-project (:width 15 :face success))             ; return project name using `projectile'
                      (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))  ; return file path relative to project root or `default-directory' if project is nil
                     :predicate
                     (lambda (cand)
                       (if-let ((buffer (get-buffer cand)))
                           ;; Don't mess with EXWM buffers
                           (with-current-buffer buffer
                             (not (derived-mode-p 'exwm-mode)))))))))

(use-package counsel
  :demand t
  :bind (("M-x" . counsel-M-x)
         ("C-x b" . counsel-ibuffer)
         ("C-x C-f" . counsel-find-file)
         ("C-M-l" . counsel-imenu)
         ([remap describe-function] . counsel-describe-function)
         ([remap describe-variable] . counsel-describe-variable)
         :map minibuffer-local-map
         ("C-r" . 'counsel-minibuffer-history))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (setq ivy-initial-inputs-alist nil) ;; Don't start searches with ^
  (counsel-mode 1))

(use-package flx  ;; Improves sorting for fuzzy-matched results
  :after ivy
  :defer t
  :init
  (setq ivy-flx-limit 10000))

(use-package smex ;; Adds M-x recent command sorting for counsel-M-x
  :defer 1
  :after counsel)

(use-package wgrep)

(use-package ivy-posframe
  :disabled
  :custom
  (ivy-posframe-width      115)
  (ivy-posframe-min-width  115)
  (ivy-posframe-height     10)
  (ivy-posframe-min-height 10)
  :config
  (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
  (setq ivy-posframe-parameters '((parent-frame . nil)
                                  (left-fringe . 8)
                                  (right-fringe . 8)))
  (ivy-posframe-mode 1))

(use-package prescient
  :after counsel
  :config
  (prescient-persist-mode 1))

(use-package ivy-prescient
  :after prescient
  :config
  (ivy-prescient-mode 1))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-ivy"

"emacs-ivy-rich"

"emacs-counsel"

;; "emacs-ivy-posframe"

"emacs-prescient"

"emacs-flx"

"emacs-wgrep"

#+end_src

** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs'
=describe-= command buffers. For example, if you use =describe-function=, you
will not only get the documentation about the function, you will also see the
source code of the function and where it gets used in other places in the
Emacs configuration. It is very useful for figuring out how things work in
Emacs.

#+begin_src emacs-lisp

(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key)
  ("C-." . helpful-at-point)
  ("C-h c". helpful-command))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-helpful"

#+end_src

** Helpful and Help Buffer Placement

#+begin_src emacs-lisp

(defvar pjp/help-buffers '("^\\*Help\\*$"
                           "^\\*helpful"))

(while pjp/help-buffers
  (add-to-list 'display-buffer-alist
               `(,(car pjp/help-buffers)
                 (display-buffer-pop-up-frame)
                 ))
  (setq pjp/help-buffers (cdr pjp/help-buffers)))

#+end_src

** Jumping with Avy

#+begin_src emacs-lisp

(use-package avy
  :commands (avy-goto-char avy-goto-word-0 avy-goto-line))

(use-package avy
  :bind (("C-:" . avy-goto-char)
         ("C-;" . avy-goto-char-2)
         ("M-g f" . avy-goto-line)
         ("M-g w" . avy-goto-word-1)
         ("M-g e" . avy-goto-word-0)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-avy"

#+end_src

** Expand Region

This module is absolutely necessary for working inside of Emacs Lisp files,
especially when trying to some parent of an expression (like a =setq=).  Makes
tweaking Org agenda views much less annoying.

#+begin_src emacs-lisp

(use-package expand-region
  :bind (("M-[" . er/expand-region)
         ("M-]" . er/contract-region)
         ("C-(" . er/mark-outside-pairs)
         ("C-)" . er/mark-inside-pairs)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-expand-region"

#+end_src

* Editing Configuration
** Use spaces instead of tabs for indentation

#+begin_src emacs-lisp

(setq-default indent-tabs-mode nil)

#+end_src

** Whitespace

#+begin_src emacs-lisp

(setq-default show-trailing-whitespace t)
(dolist (hook '(special-mode-hook
                term-mode-hook
                comint-mode-hook
                compilation-mode-hook
                minibuffer-setup-hook))
  (add-hook hook
            (lambda () (setq show-trailing-whitespace nil))))

#+end_src

* Use Parinfer for Lispy languages

#+begin_src emacs-lisp

(use-package parinfer
  :disabled
  :hook ((clojure-mode . parinfer-mode)
         (emacs-lisp-mode . parinfer-mode)
         (common-lisp-mode . parinfer-mode)
         (scheme-mode . parinfer-mode)
         (lisp-mode . parinfer-mode))
  :config
  (setq parinfer-extensions
        '(defaults       ; should be included.
           pretty-parens  ; different paren styles for different modes.
           smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
           smart-yank)))  ; Yank behavior depend on mode.

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-parinfer-mode"

#+end_src

** Origami.el for Folding

#+begin_src emacs-lisp

(use-package origami
  :hook (yaml-mode . origami-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-origami-el"

#+end_src

* Window Management
** Control Buffer Placement

Emacs' default buffer placement algorithm is pretty disruptive if you like
setting up window layouts a certain way in your workflow. The
=display-buffer-alist= video controls this behavior and you can customize it to
prevent Emacs from popping up new windows when you run commands.

#+begin_src emacs-lisp

(setq display-buffer-base-action
      '(display-buffer-reuse-mode-window
        display-buffer-reuse-window
        display-buffer-same-window))

;; If a popup does happen, don't resize windows to be equal-sized
(setq even-window-sizes nil)

#+end_src

* Credential Management

I use [[https://www.passwordstore.org/][pass]] to manage all of my passwords
locally. I also use
[[https://github.com/DamienCassou/auth-password-store][auth-source-pass]] as the
primary =auth-source= provider so that all passwords are stored in a single
place.

#+begin_src emacs-lisp

(use-package password-store
  :config
  (setq password-store-password-length 12))

(use-package auth-source-pass
  :config
  (auth-source-pass-enable))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-password-store"

"emacs-auth-source-pass"

#+end_src
* File Browsing
** Dired

#+begin_src emacs-lisp

(use-package dired
  :defer 1
  :hook (dired-mode . dired-hide-details-mode)
  :bind (:map dired-mode-map
              ("C-b" . dired-single-up-directory)
              ("C-f" . dired-single-buffer))
  :commands (dired dired-jump)
  :config
  (setq dired-listing-switches "-agho --group-directories-first"
        dired-omit-verbose nil)

  (defun find-text-files ()
    "Find all text files in path recursively, not in .git directory."
    (interactive)
    (find-dired default-directory
                "-type f \
               -not -path \"*/.git/*\" \
               -not -path \"*.pdf\" \
               -not -path \"*.zip\" \
               -not -path \"*.png\" \
               -not -path \"*.jpg\" \
               -not -path \"*.gif\" \
               -not -path \"*.exe\" \
               -not -path \"*.odt\" \
"))

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode)))

#+end_src

#+begin_src emacs-lisp :tangle no

(use-package dired-hide-dotfiles
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :bind (:map dired-mode-map
              ("." . dired-hide-dotfiles-mode)))

#+end_src

#+begin_src emacs-lisp :tangle no

(use-package dired-single
  :after dired
  :bind (:map dired-mode-map
              ("C-b" . dired-single-up-directory)
              ("C-f" . dired-single-buffer)))

#+end_src

#+begin_src emacs-lisp

(use-package dired-subtree
  :after dired
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-cycle)))

(use-package dired-collapse
  :after dired
  :hook (dired-mode . dired-collapse-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

;;"emacs-dired-single"

#+end_src

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-dired-hacks"

"emacs-all-the-icons-dired"

#+end_src

** Opening Files Externally

#+begin_src emacs-lisp

;; (use-package openwith
;;   :config
;;   (setq openwith-associations
;;         (list
;;          (list (openwith-make-extension-regexp
;;                 '("mpg" "mpeg" "mp3" "mp4"
;;                   "avi" "wmv" "wav" "mov" "flv"
;;                   "ogm" "ogg" "mkv"))
;;                "mpv"
;;                '(file))
;;          (list (openwith-make-extension-regexp
;;                 '("xbm" "pbm" "pgm" "ppm" "pnm"
;;                   "png" "gif" "bmp" "tif" "jpeg")) ;; Removed jpg because Telega was
;;                ;; causing feh to be opened...
;;                "feh"
;;                '(file))
;;          (list (openwith-make-extension-regexp
;;                 '("pdf"))
;;                "zathura"
;;                '(file))))
;;   (openwith-mode 1))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-openwith"

#+end_src

* Org Mode

Set up Org Mode with a baseline configuration.  The following sections will add more things to it.

#+begin_src emacs-lisp

;; Turn on indentation and auto-fill mode for Org files
(defun pjp/org-mode-setup ()
  (org-indent-mode)
  (diminish org-indent-mode)
  (variable-pitch-mode 1)
  (auto-fill-mode 0)
  )

(use-package org
  :defer t
  :hook (org-mode . pjp/org-mode-setup)
  :config
  (setq org-ellipsis " â–¾"
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 2
        org-hide-block-startup nil
        org-src-preserve-indentation t
        org-startup-folded 'content
        org-descriptive-links nil
        org-cycle-separator-lines 2)

  (setq org-modules
        '(org-crypt
          org-habit
          org-bookmark
          org-eshell
          org-irc))

  (setq org-refile-targets '((nil :maxlevel . 1)
                             (org-agenda-files :maxlevel . 1)))

  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-use-outline-path t)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (python . t)
     (ledger . t)))

  (push '("conf-unix" . conf-unix) org-src-lang-modes)

  ;; NOTE: Subsequent sections are still part of this use-package block!

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-org"

#+end_src

** Automatically "Tangle" on Save

Handy tip from [[https://leanpub.com/lit-config/read#leanpub-auto-configuring-emacs-and--org-mode-for-literate-programming][this book]] on literate programming.

#+begin_src emacs-lisp

;; Since we don't want to disable org-confirm-babel-evaluate all
;; of the time, do it around the after-save-hook
(defun pjp/org-babel-tangle-dont-ask ()
  ;; Dynamic scoping to the rescue
  (let ((org-confirm-babel-evaluate nil))
    (org-babel-tangle)))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'pjp/org-babel-tangle-dont-ask
                                              'run-at-end 'only-in-org-mode)))

#+end_src

** Fonts and Bullets

Set the header font sizes to something more palatable.  A fair amount of inspiration has been taken from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this blog post]].

#+begin_src emacs-lisp

(dolist (face '((org-level-1 . 1.2)
                (org-level-2 . 1.1)
                (org-level-3 . 1.05)
                (org-level-4 . 1.0)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)))
  (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

;; Make sure org-indent face is available
(require 'org-indent)

;; Ensure that anything that should be fixed-pitch in Org files appears that way
(set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)

#+end_src

** Block Templates

These templates enable you to type things like =<el= and then hit =Tab= to expand
the template.  More documentation can be found at the Org Mode [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
documentation page.

#+begin_src emacs-lisp

;; This is needed as of Org 9.2
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src sh"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
(add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
(add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
(add-to-list 'org-structure-template-alist '("json" . "src json"))

#+end_src

** Org Roam

#+begin_src emacs-lisp

(use-package org-roam
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory (file-truename "~/Repositories/peter/org/roam"))
  (org-roam-completion-everywhere t)
  (org-roam-completion-system 'default)
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n g" . org-roam-graph)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n c" . org-roam-capture)
         ;; Dailies
         ("C-c n j" . org-roam-dailies-capture-today))
  :config
  (org-roam-db-autosync-mode)
  ;; If using org-roam-protocol
  (require 'org-roam-protocol))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-org-roam"

#+end_src

** End =use-package org-mode=

#+begin_src emacs-lisp

;; This ends the use-package org-mode block
)

#+end_src

** Exporting

#+begin_src emacs-lisp

(setq org-src-fontify-natively t
      org-src-tab-acts-natively t)

(setq org-descriptive-links nil)

(eval-after-load "org"
  '(require 'ox-org nil t))

(eval-after-load "org"
  '(require 'ox-md nil t))

(eval-after-load "org"
  '(require 'ox-gfm nil t))

(defun org-include-img-from-pdf (&rest _)
  "Convert pdf files to image files in org-mode bracket links.

                                                                         # ()convertfrompdf:t # This is a special comment; tells that the upcoming
                                                                                                                                                                # link points to the to-be-converted-to file.
                                                                         # If you have a foo.pdf that you need to convert to foo.png, use the
                                                                         # foo.png file name in the link.
                                                                         [[./foo.png]]
                                                         "
  (interactive)
  (if (executable-find "convert")
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\s-+()convertfrompdf\\s-*:\\s-*t"
                                  nil :noerror)
          ;; Keep on going to the next line till it finds a line with bracketed
          ;; file link.
          (while (progn
                   (forward-line 1)
                   (not (looking-at org-bracket-link-regexp))))
          ;; Get the sub-group 1 match, the link, from `org-bracket-link-regexp'
          (let ((link (match-string-no-properties 1)))
            (when (stringp link)
              (let* ((imgfile (expand-file-name link))
                     (pdffile (expand-file-name
                               (concat (file-name-sans-extension imgfile)
                                       "." "pdf")))
                     (cmd (concat "convert -density 96 -quality 85 "
                                  pdffile " " imgfile)))
                (when (and (file-readable-p pdffile)
                           (file-newer-than-file-p pdffile imgfile))
                  ;; This block is executed only if pdffile is newer than
                  ;; imgfile or if imgfile does not exist.
                  (shell-command cmd)
                  (message "%s" cmd)))))))
    (user-error "`convert' executable (part of Imagemagick) is not found")))

;; (defun my/org-include-img-from-pdf-before-save ()
;;   "Execute `org-include-img-from-pdf' just before saving the file."
;;     (add-hook 'before-save-hook #'org-include-img-from-pdf nil :local))
;; (add-hook 'org-mode-hook #'my/org-include-img-from-pdf-before-save)

;; If you want to attempt to auto-convert PDF to PNG  only during exports, and not during each save.
(with-eval-after-load 'ox
  (add-hook 'org-export-before-processing-hook #'org-include-img-from-pdf))

(defconst help/org-special-pre "^\s*#[+]")
(defun help/org-2every-src-block (fn)
  "Visit every Source-Block and evaluate `FN'."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t))
      (while (re-search-forward (concat help/org-special-pre "BEGIN_SRC") nil t)
        (let ((element (org-element-at-point)))
          (when (eq (org-element-type element) 'src-block)
            (funcall fn element)))))
    (save-buffer)))
;;(define-key org-mode-map (kbd "M-]") (lambda () (interactive)
;;                                                                                                                                                       (help/org-2every-src-block
;;                                                                                                                                                              'org-babel-remove-result)))

#+end_src

* Development

Configuration for various programming languages and dev tools that I use.

** Languages

*** IDE Features with lsp-mode

**** lsp-mode

We use the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] to enable IDE-like functionality for many
different programming languages via "language servers" that speak the
[[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]]. Before trying to set up =lsp-mode= for a
particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that
you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where
=lsp-mode='s default keybindings will be added. I *highly recommend* using
the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys
so you should be able to learn a lot just by pressing =C-c l= in a
=lsp-mode= buffer and trying different things that you find there.

#+begin_src emacs-lisp

(defun pjp/lsp-mode-setup ()
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  (lsp-headerline-breadcrumb-mode))

(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :hook (lsp-mode . pjp/lsp-mode-setup)
  :init
  (setq lsp-keymap-prefix "s-l")  ;; Or 'C-l', 'C-c l'
  :config
  (lsp-enable-which-key-integration t))

#+end_src

**** lsp-ui

[[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] is a set of UI enhancements built on top of =lsp-mode= which make
Emacs feel even more like an IDE. Check out the screenshots on the =lsp-ui=
homepage (linked at the beginning of this paragraph) to see examples of
what it can do.

#+begin_src emacs-lisp

(use-package lsp-ui
  :hook (lsp-mode . lsp-ui-mode)
  :custom
  (lsp-ui-doc-position 'bottom))

#+end_src

**** lsp-treemacs

[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code
like symbols in a file, references of a symbol, or diagnostic messages
(errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

  This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some
  interest to you if you like to have a file browser at the left side of your
  screen in your editor.

  #+begin_src emacs-lisp

(use-package lsp-treemacs
  :after lsp)

  #+end_src

**** lsp-ivy

[[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy]] integrates Ivy with =lsp-mode= to make it easy to search for things
by name in your code. When you run these commands, a prompt will appear in
the minibuffer allowing you to type part of the name of a symbol in your
code. Results will be populated in the minibuffer so that you can find what
you're looking for and jump to that location in the code upon selecting the
result.

Try these commands with =M-x=:

- =lsp-ivy-workspace-symbol= - Search for a symbol name in the current project workspace
- =lsp-ivy-global-workspace-symbol= - Search for a symbol name in all active project workspaces

  #+begin_src emacs-lisp

(use-package lsp-ivy
  :commands lsp-ivy-workspace-symbol)

  #+end_src

  *Guix Packages*

  #+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-lsp-mode"

"emacs-lsp-ui"

"emacs-ivy-xref"

"emacs-lsp-ivy"

  #+end_src

*** Debugging with dap-mode

[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to
Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]]. You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration
docs]] to learn how to configure the debugger for your language. Also make
sure to check out the documentation for the debug adapter to see what
configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp
(use-package dap-mode
  :commands dap-mode
  :hook (dap-stopped . (lambda (arg) (call-interactively #'dap-hydra)))
  :config
  (dap-mode 1)
  (require 'dap-ui)
  (dap-ui-mode 1)
  (require 'dap-lldb))

#+end_src

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-dap-mode"

#+end_src

*** Python

We use =lsp-mode= and =dap-mode= to provide a more complete development
environment for Python in Emacs. Check out [[https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/][the =pyls= configuration]] in the
=lsp-mode= documentation for more details.

Make sure you have the =pyls= language server installed before trying =lsp-mode=!

#+begin_src sh :tangle no

pip install --user "python-language-server[all]"

#+end_src

There are a number of other language servers for Python so if you find that
=pyls= doesn't work for you, consult the =lsp-mode= [[https://emacs-lsp.github.io/lsp-mode/page/languages/][language configuration
documentation]] to try the others!

#+begin_src emacs-lisp :tangle no

(use-package python-mode
  :hook (python-mode . lsp-deferred)
  :custom
  ;; NOTE: Set these if Python 3 is called "python3" on your system!
  (python-shell-interpreter "python3")
  (dap-python-executable "python3")
  (dap-python-debugger 'debugpy)
  :config
  (require 'dap-python))


#+end_src

You can use the pyvenv package to use =virtualenv= environments in Emacs.
The =pyvenv-activate= command should configure Emacs to cause =lsp-mode= and
=dap-mode= to use the virtual environment when they are loaded, just select
the path to your virtual environment before loading your project.

#+begin_src emacs-lisp :tangle no

(use-package pyvenv
  :config
  (pyvenv-mode 1))

#+end_src

*** Send e-mail for Git patches

OK, this isn't Emacs configuration, but it's relevant to development!

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"git"
"git:send-email"

#+end_src
** Company Mode

[[http://company-mode.github.io/][Company Mode]] provides a nicer in-buffer completion interface than
=completion-at-point= which is more reminiscent of what you would expect from an
IDE. We add a simple configuration to make the keybindings a little more useful
(=TAB= now completes the selection and initiates completion at the current
location if needed).

We also use [[https://github.com/sebastiencs/company-box][company-box]] to further enhance the look of the completions with
icons and better overall presentation.

#+begin_src emacs-lisp

(use-package company
  :defer t
  :init (global-company-mode)
  :config
  (progn
    ;; Use Company for completion
    (bind-key [remap completion-at-point] #'company-complete company-mode-map)

    (setq company-tooltip-align-annotations t
          ;; Easy navigation to candidates with M-<n>
          company-show-numbers t)
    (setq company-dabbrev-downcase nil))
  :diminish company-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-company"

#+end_src

** Git

*** Magit

https://magit.vc/manual/magit/

#+begin_src emacs-lisp

(use-package magit
  :commands (magit-status magit-get-current-branch)
  :diminish magit-auto-revert-mode
  :bind (("C-x g" . magit-status))
  :config
  (progn
    (setq magit-completing-read-function 'ivy-completing-read)
    (setq magit-item-highlight-face 'bold))
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-magit"

#+end_src

*** Forge

#+begin_src emacs-lisp

(use-package forge
  :disabled)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

;;"emacs-forge"

#+end_src

*** magit-todos

This is an interesting extension to Magit that shows a TODOs section in your
git status buffer containing all lines with TODO (or other similar words) in
files contained within the repo.  More information at the [[https://github.com/alphapapa/magit-todos][GitHub repo]].

#+begin_src emacs-lisp

(use-package magit-todos
  :defer t)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-magit-todos"

#+end_src

** Projectile

*** Initial Setup

#+begin_src emacs-lisp

(use-package projectile
  :diminish projectile-mode
  :config (projectile-mode)
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init
  (when (file-directory-p "~/git")
    (setq projectile-project-search-path '("~/git")))
  (setq projectile-switch-project-action #'projectile-dired))

(use-package counsel-projectile
  :disabled
  :after projectile
  :config
  (counsel-projectile-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-projectile"

"emacs-counsel-projectile"

"ripgrep" ;; For counsel-projectile-rg

"the-silver-searcher" ;; For counsel-projectile-ag

#+end_src

*** Project Configurations

This section contains project configurations for specific projects that I can't
drop a =.dir-locals.el= file into.  Documentation on this approach can be found in
the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Directory-Local-Variables.html][Emacs manual]].

#+begin_src emacs-lisp

#+end_src

** Languages

*** Language Server Support

#+begin_src emacs-lisp :tangle no

(use-package ivy-xref
  :init (if (< emacs-major-version 27)
            (setq xref-show-xrefs-function #'ivy-xref-show-xrefs)
          (setq xref-show-definitions-function #'ivy-xref-show-defs)))

(use-package lsp-mode
  :commands lsp
  :hook ((python-mode) . lsp)
  :bind (:map lsp-mode-map
              ("TAB" . completion-at-point)))

(use-package lsp-ui
  :hook (lsp-mode . lsp-ui-mode)
  :config
  (setq lsp-ui-sideline-enable t)
  (setq lsp-ui-sideline-show-hover nil)
  (setq lsp-ui-doc-position 'bottom)
  (lsp-ui-doc-show))

#+end_src

*** Debug Adapter Support

Not so convinced about this yet.

#+begin_src emacs-lisp :tangle no

(use-package dap-mode
  :hook (lsp-mode . dap-mode)
  :config
  (dap-ui-mode 1)
  (dap-tooltip-mode 1)
  (require 'dap-node)
  (dap-node-setup)

  (dap-register-debug-template "Node: Attach"
                               (list :type "node"
                                     :cwd nil
                                     :request "attach"
                                     :program nil
                                     :port 9229
                                     :name "Node::Run")))

#+end_src

*** TypeScript and JavaScript

Set up nvm so that we can manage Node versions

#+begin_src emacs-lisp

(use-package nvm
  :defer t)

#+end_src

Configure TypeScript and JavaScript language modes

#+begin_src emacs-lisp

(use-package typescript-mode
  :mode "\\.ts\\'"
  :config
  (setq typescript-indent-level 2))

(setq js-indent-level 2)
(setq js2-basic-offset 2)
(setq js2-mode-show-strict-warnings nil)

(use-package js2-mode
  :mode "\\.jsx?\\'"
  :config
  ;; Use js2-mode for Node scripts
  (add-to-list 'magic-mode-alist '("#!/usr/bin/env node" . js2-mode)))

(use-package prettier-js
  :hook ((js2-mode . prettier-js-mode)
         (typescript-mode . prettier-js-mode))
  :config
  (setq prettier-js-show-errors nil))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-js2-mode"

"emacs-typescript-mode"

"emacs-apheleia"

"emacs-prettier"

#+end_src

*** C/C++

#+begin_src emacs-lisp :tangle no

(use-package ccls
  :hook ((c-mode c++-mode objc-mode cuda-mode) .
         (lambda () (require 'ccls) (lsp))))

;; Unfortunately many standard c++ header files have no file
;; extension, and so will not typically be identified by emacs as c++
;; files. The following code is intended to solve this problem.
(require 'cl)

#+end_src


#+begin_src emacs-lisp

(defun file-in-directory-list-p (file dirlist)
  "Returns true if the file specified is contained within one of
                                        the directories in the list. The directories must also exist."
  (let ((dirs (mapcar 'expand-file-name dirlist))
        (filedir (expand-file-name (file-name-directory file))))
    (and
     (file-directory-p filedir)
     (member-if (lambda (x) ; Check directory prefix matches
                  (string-match (substring x 0 (min(length filedir) (length x))) filedir))
                dirs))))

(defun buffer-standard-include-p ()
  "Returns true if the current buffer is contained within one of
                                        the directories in the INCLUDE environment variable."
  (and (getenv "INCLUDE")
       (file-in-directory-list-p buffer-file-name (split-string (getenv "INCLUDE") path-separator))))

(add-to-list 'magic-fallback-mode-alist '(buffer-standard-include-p . c++-mode))

;; function decides whether .h file is C or C++ header, sets C++ by
;; default because there's more chance of there being a .h without a
;; .cc than a .h without a .c (ie. for C++ template files)
(defun c-c++-header ()
  "sets either c-mode or c++-mode, whichever is appropriate for
                                        header"
  (interactive)
  (let ((c-file (concat (substring (buffer-file-name) 0 -1) "c")))
    (if (file-exists-p c-file)
        (c-mode)
      (c++-mode))))
(add-to-list 'auto-mode-alist '("\\.h\\'" . c-c++-header))
;; and if that doesn't work, a function to toggle between c-mode and
;; c++-mode
(defun c-c++-toggle ()
  "toggles between c-mode and c++-mode"
  (interactive)
  (cond ((string= major-mode "c-mode")
         (c++-mode))
        ((string= major-mode "c++-mode")
         (c-mode))))

(add-to-list 'auto-mode-alist '("\\.ino\\'" . c++-mode))

;; ROS style formatting
(defun ROS-c-mode-hook()
  (setq c-basic-offset 2)
  (setq indent-tabs-mode nil)
  (c-set-offset 'substatement-open 0)
  (c-set-offset 'innamespace 0)
  (c-set-offset 'case-label '+)
  (c-set-offset 'brace-list-open 0)
  (c-set-offset 'brace-list-intro '+)
  (c-set-offset 'brace-list-entry 0)
  (c-set-offset 'member-init-intro 0)
  (c-set-offset 'statement-case-open 0)
  (c-set-offset 'arglist-intro '+)
  (c-set-offset 'arglist-cont-nonempty '+)
  (c-set-offset 'arglist-close '+)
  (c-set-offset 'template-args-cont '+))
(add-hook 'c-mode-common-hook 'ROS-c-mode-hook)
#+end_src

*** Emacs Lisp

#+begin_src emacs-lisp

(add-hook 'emacs-lisp-mode-hook #'flycheck-mode)

(use-package paredit
  :config
  (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
  )

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-paredit"

#+end_src

*** Scheme

#+begin_src emacs-lisp

;; TODO: This causes issues for some reason.
;; :bind (:map geiser-mode-map
;;        ("TAB" . completion-at-point))

(use-package geiser
  :config
  ;; (setq geiser-default-implementation 'gambit)
  (setq geiser-default-implementation 'guile)
  (setq geiser-active-implementations '(gambit guile))
  (setq geiser-repl-default-port 44555) ; For Gambit Scheme
  (setq geiser-implementations-alist '(((regexp "\\.scm$") gambit)
                                       ((regexp "\\.sld") gambit))))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-geiser"

"emacs-geiser-guile"

#+end_src
*** Markdown

#+begin_src emacs-lisp

(use-package markdown-mode
  :mode "\\.md\\'"
  :config
  (setq markdown-command "marked")
  (defun pjp/set-markdown-header-font-sizes ()
    (dolist (face '((markdown-header-face-1 . 1.2)
                    (markdown-header-face-2 . 1.1)
                    (markdown-header-face-3 . 1.0)
                    (markdown-header-face-4 . 1.0)
                    (markdown-header-face-5 . 1.0)))
      (set-face-attribute (car face) nil :weight 'normal :height (cdr face))))

  (defun pjp/markdown-mode-hook ()
    (pjp/set-markdown-header-font-sizes))

  (add-hook 'markdown-mode-hook 'pjp/markdown-mode-hook))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-markdown-mode"

#+end_src

*** HTML

#+begin_src emacs-lisp

(use-package web-mode
  :mode "(\\.\\(html?\\|ejs\\|tsx\\|jsx\\)\\'"
  :config
  (setq-default web-mode-code-indent-offset 2)
  (setq-default web-mode-markup-indent-offset 2)
  (setq-default web-mode-attribute-indent-offset 2))

;; 1. Start the server with `httpd-start'
;; 2. Use `impatient-mode' on any buffer
;; (use-package impatient-mode)

;; (use-package skewer-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-web-mode"

#+end_src

*** YAML

#+begin_src emacs-lisp

(use-package yaml-mode
  :mode "\\.ya?ml\\'")

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-yaml-mode"

#+end_src

*** Matlab

#+begin_src emacs-lisp :tangle no

(use-package matlab
  :mode "\\.m\\'"
  :config
  (setq matlab-indent-function t)
  (setq matlab-shell-command "matlab"))

#+end_src

** Productivity

*** Syntax checking with Flycheck

#+begin_src emacs-lisp

(use-package flycheck
  :defer t
  :hook (lsp-mode . flycheck-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-flycheck"

#+end_src

*** Snippets

#+begin_src emacs-lisp

(use-package yasnippet
  :hook (prog-mode . yas-minor-mode)
  :config
  (yas-reload-all))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-yasnippet"

"emacs-yasnippet-snippets"

;; "emacs-ivy-yasnippet"  ;; Not in config yet

#+end_src

*** Smart Parens

#+begin_src emacs-lisp

(use-package smartparens
  :hook (prog-mode . smartparens-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-smartparens"

#+end_src

*** Rainbow Delimiters

#+begin_src emacs-lisp

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-rainbow-delimiters"

#+end_src

*** Rainbow Mode

Sets the background of HTML color strings in buffers to be the color mentioned.

#+begin_src emacs-lisp

(use-package rainbow-mode
  :defer t
  :hook (org-mode
         emacs-lisp-mode
         web-mode
         typescript-mode
         js2-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-rainbow-mode"

#+end_src

* Terminals
** term-mode

=term-mode= is a built-in terminal emulator in Emacs. Because it is written
in Emacs Lisp, you can start using it immediately with very little
configuration. If you are on Linux or macOS, =term-mode= is a great choice to
get started because it supports fairly complex terminal applications (=htop=,
=vim=, etc) and works pretty reliably. However, because it is written in
Emacs Lisp, it can be slower than other options like =vterm=. The speed will
only be an issue if you regularly run console apps with a lot of output.

Run a terminal with =M-x term!=

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =C-c C-k= - Enter char-mode
- =C-c C-j= - Return to line-mode

  #+begin_src emacs-lisp

(use-package term
  :config
  (setq explicit-shell-file-name "bash") ;; Change this to zsh, etc
  ;;(setq explicit-zsh-args '())         ;; Use 'explicit-<shell>-args for shell-specific args

  ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

  #+end_src

*** Better term-mode colors

The =eterm-256color= package enhances the output of =term-mode= to enable
handling of a wider range of color codes so that many popular terminal
applications look as you would expect them to. Keep in mind that this
package requires =ncurses= to be installed on your machine so that it has
access to the =tic= program. Most Linux distributions come with this program
installed already so you may not have to do anything extra to use it.

#+begin_src emacs-lisp

(use-package eterm-256color
  :hook (term-mode . eterm-256color-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-eterm-256color"

#+end_src

** vterm

[[https://github.com/akermu/emacs-libvterm/][vterm]] is an improved terminal emulator package which uses a compiled native
module to interact with the underlying terminal applications. This enables it
to be much faster than =term-mode= and to also provide a more complete
terminal emulation experience.

Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] installed before trying to
use =vterm= because there is a module that will need to be compiled before
you can use it successfully.

#+begin_src emacs-lisp

(use-package vterm
  :commands vterm
  :config
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
  ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
  (setq vterm-max-scrollback 10000))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-vterm"

#+end_src

** shell-mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell. It is *not* a
terminal emulator so more complex terminal programs will not run inside of
it. It does have much better integration with Emacs because all command input
in this mode is handled by Emacs and then sent to the underlying shell once
you press Enter.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

  One advantage of =shell-mode= on Windows is that it's the only way to run
  =cmd.exe=, PowerShell, Git Bash, etc from within Emacs. Here's an example of
  how you would set up =shell-mode= to run PowerShell on Windows:

  #+begin_src emacs-lisp

(when (eq system-type 'windows-nt)
  (setq explicit-shell-file-name "powershell.exe")
  (setq explicit-powershell.exe-args '()))

  #+end_src

** eshell

#+begin_src emacs-lisp

(defun pjp/configure-eshell ()
  ;; Save command history when commands are entered
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

  ;; Truncate buffer for performance
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

  (setq eshell-history-size         10000
        eshell-buffer-maximum-lines 10000
        eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t))

(use-package eshell
  :hook ((eshell-first-time-mode . pjp/configure-eshell)))

(use-package eshell-up)

(use-package eshell-toggle
  :custom
  (eshell-toggle-size-fraction 4)
  (eshell-toggle-run-command nil)
  :bind
  ("C-`" . eshell-toggle))

(use-package eshell-syntax-highlighting
  :after eshell-mode
  :config
  ;; Enable in all Eshell buffers.
  (eshell-syntax-highlighting-global-mode +1))

(with-eval-after-load "esh-opt"
  (autoload 'epe-theme-multiline-with-status "eshell-prompt-extras")
  (setq eshell-highlight-prompt nil
        eshell-prompt-function 'epe-theme-multiline-with-status))

;; (with-eval-after-load "esh-opt"
;;   (require 'virtualenvwrapper)
;;   (venv-initialize-eshell)
;;   (autoload 'epe-theme-lambda "eshell-prompt-extras")
;;   (setq eshell-highlight-prompt nil
;;         eshell-prompt-function 'epe-theme-lambda))

;; (eshell-did-you-mean-setup)

(use-package eshell-bookmark
  :after eshell
  :config
  (add-hook 'eshell-mode-hook #'eshell-bookmark-setup))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

;; "emacs-eshell-z"

"emacs-eshell-up"

"emacs-eshell-toggle"

"emacs-eshell-syntax-highlighting"

"emacs-eshell-prompt-extras"

"emacs-eshell-did-you-mean"

"emacs-eshell-bookmark"

#+end_src

* Applications
** Email

My mail configuration is stored in [[file:Email.org][Email.org]]. We merely
require it here to have it loaded in the main Emacs configuration.

#+begin_src emacs-lisp

;; Only fetch mail on knave
;; (setq pjp/mail-enabled (member system-name '("knave" "precision")))
;; (setq pjp/mu4e-inbox-query nil)
;; (when pjp/mail-enabled
;;   (require 'pjp-email))
(global-set-key (kbd "C-x e") (lambda() (interactive) (load "~/.emacs.d/lisp/pjp-email.el")))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""

"emacs-mu4e-alert"

"emacs-org-mime"

#+end_src

** Arduino

#+begin_src emacs-lisp

(setq auto-mode-alist (cons '("\\.\\(pde\\|ino\\)$" . c++-mode) auto-mode-alist))

#+end_src

* System Utilities
** Guix

#+begin_src emacs-lisp

(use-package guix
  :defer t)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-guix"

#+end_src

** Daemons

#+begin_src emacs-lisp

(use-package daemons
  :commands daemons)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-daemons"

#+end_src

** Docker

#+begin_src emacs-lisp

(use-package docker
  :commands docker)

(use-package docker-tramp
  :defer t
  :after docker)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

;; "emacs-docker"

;; "emacs-docker-tramp"

;; "emacs-dockerfile-mode"

#+end_src

* Guix Perfect Setup

#+begin_src emacs-lisp

(with-eval-after-load 'geiser-guile
  (add-to-list 'geiser-guile-load-path "~/guix"))
(with-eval-after-load 'yasnippet
  (add-to-list 'yas-snippet-dirs "~/guix/etc/snippets"))
(load-file "~/guix/etc/copyright.el")

#+end_src
* Development Environment
** direnv

#+begin_src emacs-lisp

(envrc-global-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""

"emacs-envrc"

#+end_src
* Emacs Profile

*.config/guix/manifests/emacs.scm:*

#+begin_src scheme :scheme guile :session guile :tangle .config/guix/manifests/emacs.scm :noweb yes

(specifications->manifest
 '("emacs"
   <<packages>>
   ))

#+end_src
