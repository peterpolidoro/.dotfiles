#+title: Peter Polidoro Emacs Configuration
#+AUTHOR: Peter Polidoro
#+EMAIL: peter@polidoro.io
#+LANGUAGE: en
#+OPTIONS: toc:2 num:nil ^:nil
#+PROPERTY: header-args:emacs-lisp :tangle ./.config/emacs/init.el :mkdirp yes :results silent
#+PROPERTY: header-args:shell :results verbatim :exports both
#+STARTUP: fold
#+auto_tangle: t

* Introduction

This is a reproducible, literate configuration for **GNU Emacs 30.2** managed by
**GNU Guix**. It tangles four files:

- =.config/emacs/early-init.el=      (pre-GUI/startup tuning)
- =.config/emacs/init.el=            (main configuration)
- =.config/guix/manifests/emacs.scm=  (Guix manifest containing Emacs packages + tools + Tree‑sitter grammars)
- =.config/emacs/custom.el=     (Custom variables written by Customize; empty stub here)

To tangle everything: =C-c C-v t= (or =M-x org-babel-tangle=) from this buffer.

* early-init.el  (tangled to =.config/emacs/early-init.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./.config/emacs/early-init.el :mkdirp yes :results silent
:END:

#+begin_src emacs-lisp
;;; early-init.el --- Early startup tweaks -*- lexical-binding: t; -*-
;; NOTE: This file is generated from Emacs.org.  Please edit that file
;;       in Emacs and this file will be generated automatically!

;; We use Guix profiles for packages; don't let package.el initialize.
(setq package-enable-at-startup nil)

;; Avoid frame flicker / resizing during init.
(setq frame-inhibit-implied-resize t)

;; Hide UI chrome as early as possible (we can re-enable in init if desired).
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)

;; Speed up startup by deferring file-name handlers; restore after init.
(let ((old file-name-handler-alist))
  (setq file-name-handler-alist nil)
  (add-hook 'emacs-startup-hook
            (lambda () (setq file-name-handler-alist old))))
#+end_src

* Core: package discipline, performance, UI

** Package discipline (Guix‑first)
We assume you install Emacs packages via Guix. We still use =use-package= for
declarative setup, but without network installs.

#+begin_src emacs-lisp
;;; init.el --- Main configuration -*- lexical-binding: t; -*-
;; NOTE: This file is generated from Emacs.org.  Please edit that file
;;       in Emacs and this file will be generated automatically!

;; Don’t let package.el mess with Guix-managed packages.
(setq package-enable-at-startup nil)

;; use-package: installed via Guix as `emacs-use-package`
(eval-when-compile
  (require 'use-package))
(setq use-package-always-ensure nil
      use-package-expand-minimally t
      use-package-compute-statistics t)
#+end_src

** Performance: GC + native-comp + scrolling
#+begin_src emacs-lisp
;; Big GC threshold during init; restore after startup.
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6)
(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold (* 64 1024 1024)
                  gc-cons-percentage 0.1)))

;; Quiet native-comp warnings; native-compile packages when available.
(when (boundp 'native-comp-async-report-warnings-errors)
  (setq native-comp-async-report-warnings-errors 'silent))
(setq package-native-compile t)

;; Smooth, precise scrolling (Emacs 29+).
(when (fboundp 'pixel-scroll-precision-mode)
  (pixel-scroll-precision-mode 1))
#+end_src

** Basic UI
#+begin_src emacs-lisp
;; Minimal distractions; these were already suppressed in early-init.
(menu-bar-mode -1)
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

;; Sensible defaults
(setq inhibit-startup-screen t
      initial-scratch-message nil
      ring-bell-function #'ignore
      confirm-kill-emacs #'y-or-n-p)

;; Show line/column numbers when useful
(setq display-line-numbers-type 'relative)
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(setq column-number-mode t)

;; Better y/n prompts
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Who am I?
#+begin_src emacs-lisp
(setq user-full-name "Peter Polidoro"
      user-mail-address "peter@polidoro.io")
(setq copyright-names-regexp
      (format "%s <%s>" user-full-name user-mail-address))
#+end_src

** Font Size
#+begin_src emacs-lisp
;; Adjust this font size for each system
(defvar pjp/default-font-size 120)
(defvar pjp/default-variable-font-size 120)
#+end_src

** Handle Warnings

*** Set minimum warning level
#+begin_src emacs-lisp
(setq warning-minimum-level :error)
(when (boundp 'native-comp-async-report-warnings-errors)
  (setq native-comp-async-report-warnings-errors 'silent))
(setq package-native-compile t) ; native-compile packages when available
(require 'cl-lib)               ; use cl-lib symbols explicitly
#+end_src

** Guix Packages
#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-use-package"
#+end_src

* Guix
#+begin_src emacs-lisp
(use-package guix
  :defer t)
(add-hook 'scheme-mode-hook 'guix-devel-mode)
#+end_src

** Guix Packages
#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-guix"
"guile"
"guix"
#+end_src

* Keep .config/emacs Clean
I don't want a bunch of transient files showing up as untracked in the Git
repo so I move them all to another location.

#+begin_src emacs-lisp
;; Keep transient cruft out of ~/.config/emacs/
(setq user-emacs-directory "~/.cache/emacs/"
      backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory)))
      url-history-file (expand-file-name "url/history" user-emacs-directory)
      auto-save-list-file-prefix (expand-file-name "auto-save-list/.saves-" user-emacs-directory))

;; Use no-littering to automatically set common paths to the new user-emacs-directory
(use-package no-littering)

;; Keep customization settings in a temporary file
(setq custom-file (expand-file-name "~/.config/emacs/custom.el"))
(when (file-exists-p custom-file)
  (load custom-file 'noerror))

;; I use version control instead of backup files
(setq make-backup-files nil)
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-no-littering"
#+end_src

* Update Load Path
I've got a folder of custom Emacs Lisp libraries which must be added to the load path.

#+begin_src emacs-lisp
;; Add my library path to load-path
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+end_src

* Keyboard Bindings
** ESC Cancels All
#+begin_src emacs-lisp
(keymap-global-set "<escape>" #'keyboard-escape-quit)
#+end_src

** Keybinding Panel (which-key)
[[https://github.com/justbur/emacs-which-key][which-key]] is great for getting an overview of what keybindings are available
based on the prefix keys you entered.

#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.3))
#+end_src

*Guix Packages*
#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-which-key"
#+end_src

* General Configuration
** User Interface
*** Clean up Emacs' user interface, make it more minimal.
#+begin_src emacs-lisp
(scroll-bar-mode -1)        ; Disable visible scrollbar
(tool-bar-mode -1)          ; Disable the toolbar

; Making tooltips appear in the echo area
(tooltip-mode -1)
(setq tooltip-use-echo-area t)

(set-fringe-mode 10)        ; Give some breathing room

(menu-bar-mode -1)            ; Disable the menu bar

;; Set up the visible bell
(setq visible-bell t)
#+end_src

*** Modifying prompts
#+begin_src emacs-lisp
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message t)
(setq use-short-answers t)
(setq confirm-nonexistent-file-or-buffer nil)
(setq kill-buffer-query-functions
  (remq 'process-kill-buffer-query-function
         kill-buffer-query-functions))
#+end_src

*** Improve scrolling.
#+begin_src emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1)
#+end_src

*** Set frame transparency and maximize windows by default.

#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

*** Switching buffers

[[https://www.masteringemacs.org/article/demystifying-emacs-window-manager]]

#+begin_src emacs-lisp
(setq switch-to-buffer-obey-display-actions t)
#+end_src

*** Enable line numbers and customize their format.
#+begin_src emacs-lisp
(column-number-mode)

;; Enable line numbers for some modes
(dolist (mode '(text-mode-hook
                prog-mode-hook
                conf-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 1))))

;; Disable line numbers for some modes
(dolist (mode '(org-mode-hook
                term-mode-hook
                shell-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

*** Don't warn for large files (shows up when launching videos)

#+begin_src emacs-lisp

(setq large-file-warning-threshold nil)

#+end_src

*** Don't warn for following symlinked files

#+begin_src emacs-lisp

(setq vc-follow-symlinks t)

#+end_src

*** Don't warn when advice is added for functions

#+begin_src emacs-lisp

(setq ad-redefinition-action 'accept)

#+end_src

*** Kill whole line

#+BEGIN_SRC emacs-lisp
(setq kill-whole-line t)
#+END_SRC

*** Fill-column

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC

*** Automatically convert line endings to unix

#+BEGIN_SRC emacs-lisp
(defun no-junk-please-were-unixish ()
  (let ((coding-str (symbol-name buffer-file-coding-system)))
    (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
      (set-buffer-file-coding-system 'unix))))

(add-hook 'find-file-hooks 'no-junk-please-were-unixish)
#+END_SRC

*** Treat camel case as separate words

#+begin_src emacs-lisp

(add-hook 'after-change-major-mode-hook 'subword-mode)

#+end_src

*** Make scripts executable

#+begin_src emacs-lisp

(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

#+end_src

*** Single space after periods

#+begin_src emacs-lisp

(setq sentence-end-double-space nil)

#+end_src

*** Visual Line Mode

#+begin_src emacs-lisp

;; (global-visual-line-mode nil)

#+end_src

*** Offer to create parent directories on save

#+begin_src emacs-lisp

(add-hook 'before-save-hook
          (lambda ()
            (when buffer-file-name
              (let ((dir (file-name-directory buffer-file-name)))
                (when (and (not (file-exists-p dir))
                           (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                  (make-directory dir t))))))

#+end_src

*** Apply changes to higlighted region

#+begin_src emacs-lisp

(transient-mark-mode t)

#+end_src

*** Overwrite selected text

#+begin_src emacs-lisp

(delete-selection-mode t)

#+end_src

*** Refresh buffers when files change

#+begin_src emacs-lisp

(global-auto-revert-mode t)
(setq global-auto-revert-non-file-buffers t)

#+end_src

*** Yank to point on mouse click

#+begin_src emacs-lisp

(setq mouse-yank-at-point t)

#+end_src

*** Ensure files end with newline

#+begin_src emacs-lisp

(setq require-final-newline t)

#+end_src

*** Confirm closing Emacs

#+begin_src emacs-lisp

(setq confirm-kill-emacs 'y-or-n-p)

#+end_src

*** Use UTF-8

#+begin_src emacs-lisp

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

#+end_src

*** Truncate lines

#+begin_src emacs-lisp

(set-default 'truncate-lines t)
(setq truncate-partial-width-windows t)

#+end_src

*** Default tab width

#+begin_src emacs-lisp

(setq-default tab-width 2)

#+end_src

*** Windmove

#+begin_src emacs-lisp

(global-set-key (kbd "s-b")  'windmove-left)
(global-set-key (kbd "s-f") 'windmove-right)
(global-set-key (kbd "s-p")    'windmove-up)
(global-set-key (kbd "s-n")  'windmove-down)

#+end_src

*** Undo

#+begin_src emacs-lisp
(use-package vundo :commands vundo)
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-vundo"
#+end_src

*** Uniquify

#+begin_src emacs-lisp

(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
(setq-default frame-title-format "%b (%f)")

#+end_src

*** Golden ratio

#+BEGIN_SRC emacs-lisp

(golden-ratio-mode 1)

#+END_SRC

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-golden-ratio"
#+end_src

*** Repeat Mode

#+BEGIN_SRC emacs-lisp

(repeat-mode 1)

#+END_SRC

*** Kill buffer diff

Custom kill command that provides the option to diff a modified buffer with the
file it is visiting.

#+BEGIN_SRC emacs-lisp

(defun pjp/kill-buffer ()
  (interactive)
  (catch 'quit
    (save-window-excursion
      (let (done)
        (when (and buffer-file-name (buffer-modified-p))
          (while (not done)
            (let ((response (read-char-choice
                             (format "Save file %s? (y, n, d, q) " (buffer-file-name))
                             '(?y ?n ?d ?q))))
              (setq done (cond
                          ((eq response ?q) (throw 'quit nil))
                          ((eq response ?y) (save-buffer) t)
                          ((eq response ?n) (set-buffer-modified-p nil) t)
                          ((eq response ?d) (diff-buffer-with-file) nil))))))
        (kill-buffer (current-buffer))))))

(global-set-key [remap kill-buffer] 'pjp/kill-buffer)

#+END_SRC

** Theme

#+begin_src emacs-lisp
(load-theme 'ef-dark t)
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-modus-themes"
"emacs-ef-themes"
#+end_src

** Font

*** Set the font

Fonts are installed from the "desktop" profile.

#+begin_src emacs-lisp

  (set-face-attribute 'default nil :font "Fira Code Retina" :height pjp/default-font-size)

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height pjp/default-font-size)

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil :font "Iosevka Aile" :height pjp/default-variable-font-size :weight 'regular)

#+end_src

*** Enable proper Unicode glyph support

#+begin_src emacs-lisp

(defun pjp/replace-unicode-font-mapping (block-name old-font new-font)
  (let* ((block-idx (cl-position-if
                     (lambda (i) (string-equal (car i) block-name))
                     unicode-fonts-block-font-mapping))
         (block-fonts (cadr (nth block-idx unicode-fonts-block-font-mapping)))
         (updated-block (cl-substitute new-font old-font block-fonts :test 'string-equal)))
    (setf (cdr (nth block-idx unicode-fonts-block-font-mapping))
          `(,updated-block))))

(use-package unicode-fonts
  :disabled
  :custom
  (unicode-fonts-skip-font-groups '(low-quality-glyphs))
  :config
  ;; Fix the font mappings to use the right emoji font
  (mapcar
   (lambda (block-name)
     (pjp/replace-unicode-font-mapping block-name "Apple Color Emoji" "Noto Color Emoji"))
   '("Dingbats"
     "Emoticons"
     "Miscellaneous Symbols and Pictographs"
     "Transport and Map Symbols"))
  (unicode-fonts-setup))

#+end_src

*** Emojis in buffers

#+begin_src emacs-lisp

(use-package emojify
  :hook (erc-mode . emojify-mode)
  :commands emojify-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-emojify"
#+end_src

*** All the icons

*NOTE:* The first time you load your configuration on a new machine, you'll need to run `M-x all-the-icons-install-fonts` so that icons display correctly.

#+begin_src emacs-lisp

(use-package all-the-icons)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-all-the-icons"
#+end_src

** Mode Line

*** Doom Mode Line

#+begin_src emacs-lisp

(use-package minions
  :hook (doom-modeline-mode . minions-mode))

(use-package doom-modeline
  :after eshell     ;; Make sure it gets hooked after eshell
  :hook (after-init . doom-modeline-init)
  :custom-face
  (mode-line ((t (:height 0.85))))
  (mode-line-inactive ((t (:height 0.85))))
  :custom
  (doom-modeline-height 15)
  (doom-modeline-bar-width 6)
  (doom-modeline-lsp t)
  (doom-modeline-github nil)
  (doom-modeline-mu4e nil)
  (doom-modeline-irc t)
  (doom-modeline-icon (display-graphic-p))
  (doom-modeline-minor-modes t)
  (doom-modeline-persp-name nil)
  (doom-modeline-buffer-file-name-style 'truncate-except-project)
  (doom-modeline-major-mode-icon nil))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-minions"
"emacs-doom-modeline"
#+end_src

*** Basic Customization

#+begin_src emacs-lisp

(setq display-time-format "%l:%M %p %b %y"
      display-time-default-load-average nil)

#+end_src

*** Enable Mode Diminishing

The [[https://github.com/myrjola/diminish.el][diminish]] package hides pesky minor modes from the modelines.

#+begin_src emacs-lisp

(use-package diminish)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-diminish"
#+end_src

** Notifications

[[https://github.com/jwiegley/alert][alert]] is a great library for showing notifications from other packages in a
variety of ways. For now I just use it to surface desktop notifications from
package code.

#+begin_src emacs-lisp

(use-package alert
  :commands alert
  :config
  (setq alert-default-style 'notifications))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-alert"
#+end_src

** Auto-Reverting Changed Files

#+begin_src emacs-lisp

(global-auto-revert-mode 1)

#+end_src

** Highlight Matching Braces

#+begin_src emacs-lisp

(use-package paren
  :config
  (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
  (show-paren-mode))

#+end_src

** Displaying World Time

=display-time-world= command provides a nice display of the time at a
specified list of timezones. Nice for working in a team with remote members.

#+begin_src emacs-lisp

(setq display-time-world-list
      '(("America/Los_Angeles" "California")
        ("America/New_York" "New York")
        ("Europe/Athens" "Athens")
        ("Pacific/Auckland" "Auckland")
        ("Asia/Shanghai" "Shanghai")))
(setq display-time-world-time-format "%a, %d %b %I:%M %p %Z")

#+end_src

** Pinentry

Emacs can be prompted for the PIN of GPG private keys, we just need to set
=epa-pinentry-mode= to accomplish that:

#+begin_src emacs-lisp

  (setq epa-pinentry-mode 'loopback)
  (pinentry-start)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-pinentry"
"pinentry-emacs"
#+end_src

** TRAMP

#+begin_src emacs-lisp

;; Set default connection mode to SSH
(setq tramp-default-method "ssh")

#+end_src

** Bind keys to change text size

#+begin_src emacs-lisp

(defhydra hydra-zoom (global-map "C-=")
  "zoom"
  ("=" text-scale-increase "in")
  ("-" text-scale-decrease "out"))

#+end_src

** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs'
=describe-= command buffers. For example, if you use =describe-function=, you
will not only get the documentation about the function, you will also see the
source code of the function and where it gets used in other places in the
Emacs configuration. It is very useful for figuring out how things work in
Emacs.

#+begin_src emacs-lisp

(use-package helpful
  :bind
  ([remap describe-function] . helpful-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key)
  ;;("C-." . helpful-at-point)
  ("C-h c". helpful-command))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-helpful"
#+end_src


** Essentials (recommended defaults)
#+begin_src emacs-lisp
(savehist-mode 1)
(save-place-mode 1)
(global-auto-revert-mode 1)
(repeat-mode 1)
(column-number-mode 1)
;; Optional: auto-pairing
(electric-pair-mode 1)
#+end_src

* Stateful Keymaps with Hydra

#+begin_src emacs-lisp

(use-package hydra
  :defer 1)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-hydra"
#+end_src

* Completion System
** Vertico

#+begin_src emacs-lisp
(defun pjp/minibuffer-backward-kill (arg)
	"When minibuffer is completing a file name delete up to parent
		folder, otherwise delete a word"
	(interactive "p")
	(if minibuffer-completing-file-name
			(if (string-match-p "/." (minibuffer-contents))
					(zap-up-to-char (- arg) ?/)
				(delete-minibuffer-contents))
		(delete-word (- arg))))

(use-package vertico
	:bind (:map minibuffer-local-map
					    ("M-<backspace>" . pjp/minibuffer-backward-kill))
	:init
	(vertico-mode)

	;; Different scroll margin
	;; (setq vertico-scroll-margin 0)

	;; Show more candidates
	;; (setq vertico-count 20)

	;; Grow and shrink the Vertico minibuffer
	;; (setq vertico-resize t)

	;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
	(setq vertico-cycle t))

;; A few more useful configurations...
(use-package emacs
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  :custom
  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t)

  ;; TAB cycle if there are only few candidates
  (setq completion-cycle-threshold 3)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete)

  ;; Emacs 30 and newer: Disable Ispell completion function.
  ;; Try `cape-dict' as an alternative.
  ;;(text-mode-ispell-word-completion nil)

  ;; Hide commands in M-x which do not apply to the current mode.  Corfu
  ;; commands are hidden, since they are not used via M-x. This setting is
  ;; useful beyond Corfu.
  (read-extended-command-predicate #'command-completion-default-include-p)

  ;; Do not allow the cursor in the minibuffer prompt
  (minibuffer-prompt-properties
   '(read-only t cursor-intangible t face minibuffer-prompt))
  )
#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-vertico"
#+end_src

** Orderless

#+begin_src emacs-lisp

(use-package orderless
  :init
  ;; Configure a custom style dispatcher (see the Consult wiki)
  ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
  ;;       orderless-component-separator #'orderless-escapable-split-on-space)
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-orderless"
#+end_src

** Savehist

#+begin_src emacs-lisp
(setq history-length 25)
(use-package savehist :init (savehist-mode 1))
#+end_src

** Corfu

#+begin_src emacs-lisp
(use-package corfu
  ;; Optional customizations
  :custom
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  (corfu-auto t)                 ;; Enable auto completion
  (corfu-auto-prefix 2)
  (corfu-auto-delay 0.0)
  (corfu-quit-at-boundary 'separator)
  (corfu-echo-documentation 0.25)
  (corfu-preview-current 'insert)
  (corfu-preselect-first nil)
  ;; (corfu-separator ?\s)          ;; Orderless field separator
  ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
  ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
  ;; (corfu-scroll-margin 5)        ;; Use scroll margin

  ;; Enable Corfu only for certain modes.
  ;; :hook ((prog-mode . corfu-mode)
  ;;        (shell-mode . corfu-mode)
  ;;        (eshell-mode . corfu-mode))

  ;; Use TAB for cycling, default is `corfu-complete'.
  :bind
  (:map corfu-map
        ("M-SPC" . corfu-insert-separator)
        ;;("RET" . nil)
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous)
        ("S-<return>" . corfu-insert))

  ;; Recommended: Enable Corfu globally.  This is recommended since Dabbrev can
  ;; be used globally (M-/).  See also the customization variable
  ;; `global-corfu-modes' to exclude certain modes.
  :init
  (global-corfu-mode)
  (corfu-history-mode)
  :config
  (add-hook 'eshell-mode-hook
            (lambda () (setq-local corfu-quit-at-boundary t
                                   corfu-quit-no-match t
                                   corfu-auto nil)
              (corfu-mode)))
  :hook
  (org-edit-special-mode . corfu-mode) ; Enable corfu-mode in org-edit-special-mode
  (org-src-mode . (lambda ()
                    (corfu-mode -1)))  ; Disable corfu-mode in org-src-mode
  (org-src-exit . (lambda ()
                    (corfu-mode 1)))    ; Enable corfu-mode after exiting org-src
  )
#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-corfu"
#+end_src

** Cape

#+begin_src emacs-lisp
(use-package cape
  ;; Bind prefix keymap providing all Cape commands under a mnemonic key.
  ;; Press C-c p ? to for help.
  :bind ("M-p" . cape-prefix-map) ;; Alternative key: C-c p,m M-<tab>, M-p, M-+
  ;; Alternatively bind Cape commands individually.
  ;; :bind (("C-c p d" . cape-dabbrev)
  ;;        ("C-c p h" . cape-history)
  ;;        ("C-c p f" . cape-file)
  ;;        ...)
  :init
  ;; Add to the global default value of `completion-at-point-functions' which is
  ;; used by `completion-at-point'.  The order of the functions matters, the
  ;; first function returning a result wins.  Note that the list of buffer-local
  ;; completion functions takes precedence over the global list.
  (add-hook 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'completion-at-point-functions #'cape-file)
  (add-hook 'completion-at-point-functions #'cape-elisp-block)
  (add-hook 'completion-at-point-functions #'cape-history)
  ;; (add-hook 'completion-at-point-functions #'cape-dict)
  (add-hook 'completion-at-point-functions #'cape-keyword)
  ;; ...
)
#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-cape"
#+end_src

** Consult
#+begin_src emacs-lisp

(use-package consult
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (("C-s" . consult-line)
         ;; C-c bindings (mode-specific-map)
         ("C-c M-x" . consult-mode-command)
         ("C-c h" . consult-history)
         ("C-c k" . consult-kmacro)
         ("C-c m" . consult-man)
         ("C-c i" . consult-info)
         ([remap Info-search] . consult-info)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings (goto-map)
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI. You may want to also
  ;; enable `consult-preview-at-point-mode` in Embark Collect buffers.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme
   :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; :preview-key "M-."
   :preview-key '(:debounce 0.4 any))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
  ;;;; 2. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 3. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
  ;;;; 5. No project support
  ;; (setq consult-project-function nil)
  )

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-consult"
#+end_src

** Marginalia

#+begin_src emacs-lisp

(use-package marginalia
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init configuration is always executed (Not lazy!)
  :init

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-marginalia"
#+end_src

** Embark

#+begin_src emacs-lisp

(use-package embark
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("M-." . embark-dwim)        ;; good alternative: C-;
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook
  (embark-collect-mode . consult-preview-at-point-mode)
  )

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-embark"
#+end_src

** Completion Ignored Extensions

#+begin_src emacs-lisp

(add-to-list 'completion-ignored-extensions ".go")

#+end_src

* Casual
** Calc

#+begin_src emacs-lisp
(use-package calc
  :bind (:map calc-mode-map
              ("C-o" . casual-calc-tmenu)))
#+end_src

** Compile (Grep)

#+begin_src emacs-lisp
(use-package compile
  :bind (:map compilation-mode-map
              ("C-o" . casual-calc-tmenu)))
(use-package grep
  :bind (:map grep-mode-map
              ("C-o" . casual-calc-tmenu)))
;(keymap-set compilation-mode-map "C-o" #'casual-compile-tmenu)
;(keymap-set grep-mode-map "C-o" #'casual-compile-tmenu)
#+end_src

** EditKit

#+begin_src emacs-lisp
(keymap-global-set "C-o" #'casual-editkit-main-tmenu)
#+end_src

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-casual"
#+end_src

* Expand Region

This module is absolutely necessary for working inside of Emacs Lisp files,
especially when trying to some parent of an expression (like a =setq=).  Makes
tweaking Org agenda views much less annoying.

#+begin_src emacs-lisp

(use-package expand-region
  :bind (("M-[" . er/expand-region)
         ("M-]" . er/contract-region)
         ("C-(" . er/mark-outside-pairs)
         ("C-)" . er/mark-inside-pairs)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-expand-region"
#+end_src

* Editing Configuration
** Use spaces instead of tabs for indentation

#+begin_src emacs-lisp

(setq-default indent-tabs-mode nil)

#+end_src

** Whitespace

#+begin_src emacs-lisp

(setq-default show-trailing-whitespace t)
(dolist (hook '(special-mode-hook
                term-mode-hook
                comint-mode-hook
                compilation-mode-hook
                minibuffer-setup-hook))
  (add-hook hook
            (lambda () (setq show-trailing-whitespace nil))))

#+end_src

* Use Parinfer for Lispy languages

#+begin_src emacs-lisp

(use-package parinfer
  :disabled
  :hook ((clojure-mode . parinfer-mode)
         (emacs-lisp-mode . parinfer-mode)
         (common-lisp-mode . parinfer-mode)
         (scheme-mode . parinfer-mode)
         (lisp-mode . parinfer-mode))
  :config
  (setq parinfer-extensions
        '(defaults       ; should be included.
           pretty-parens  ; different paren styles for different modes.
           smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
           smart-yank)))  ; Yank behavior depend on mode.

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-parinfer-mode"
#+end_src

** Origami.el for Folding

#+begin_src emacs-lisp

(use-package origami
  :hook (yaml-mode . origami-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-origami-el"
#+end_src

* Credential Management

I use [[https://www.passwordstore.org/][pass]] to manage all of my passwords
locally.

#+begin_src emacs-lisp

(use-package pass)

(setq auth-sources '(password-store))
(setq auth-source-debug t)
(setq auth-source-do-cache nil)
(setq auth-source-pass-filename "~/.password-store")

(use-package auth-source-pass
  :init (auth-source-pass-enable))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-pass"
"emacs-auth-source-pass"
#+end_src

* File Browsing

** Dirvish

#+begin_src emacs-lisp

  (use-package dirvish
    :init
    (dirvish-override-dired-mode)
    :custom
    (dirvish-quick-access-entries ; It's a custom option, `setq' won't work
     '(("h" "~/" "Home")
       ("d" "~/Downloads/" "Downloads")
       ("." "~/.dotfiles/" "Dotfiles")
       ("a" "~/Repositories/arduino" "Arduino")
       ("g" "~/Repositories/guix" "Guix")
       ("k" "~/Repositories/kicad" "Kicad")
       ("o" "~/Repositories/peter/org" "Org")
       ("p" "~/Repositories/pypi" "Pypi")
       ("r" "~/Repositories/ros" "Ros")
       ))
    :config
    ;; (dirvish-peek-mode) ; Preview files in minibuffer
    ;; (dirvish-side-follow-mode) ; similar to `treemacs-follow-mode'
    ;; (setq dirvish-mode-line-format
    ;;       '(:left (sort symlink) :right (omit yank index)))
    ;; (setq dirvish-attributes
    ;;       '(all-the-icons file-time file-size collapse subtree-state vc-state git-msg))
    ;; (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
          "-l --almost-all --human-readable --group-directories-first --no-group")
    :bind ; Bind `dirvish|dirvish-side|dirvish-dwim' as you see fit
    (("C-c f" . dirvish-fd)
     :map dirvish-mode-map ; Dirvish inherits `dired-mode-map'
     ("a"   . dirvish-quick-access)
     ("f"   . dirvish-file-info-menu)
     ("y"   . dirvish-yank-menu)
     ("N"   . dirvish-narrow)
     ;; ("^"   . dirvish-history-last)
     ("h"   . dirvish-history-jump) ; remapped `describe-mode'
     ("s"   . dirvish-quicksort)    ; remapped `dired-sort-toggle-or-edit'
     ("v"   . dirvish-vc-menu)      ; remapped `dired-view-file'
     ("TAB" . dirvish-subtree-toggle)
     ("M-f" . dirvish-history-go-forward)
     ("M-b" . dirvish-history-go-backward)
     ("M-l" . dirvish-ls-switches-menu)
     ("M-m" . dirvish-mark-menu)
     ("M-t" . dirvish-layout-toggle)
     ("M-s" . dirvish-setup-menu)
     ("M-e" . dirvish-emerge-menu)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-fd"
"poppler"
"ffmpegthumbnailer"
"mediainfo"
"unzip"
"tar"
"zip"
"emacs-all-the-icons-dired"
"emacs-dirvish"
#+end_src

* Search

** ripgrep

#+begin_src emacs-lisp

(require 'rg)
(rg-enable-default-bindings)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-rg"
#+end_src

* Web Browsing

** firefox

#+begin_src emacs-lisp

(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "firefox")

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
#+end_src

** Edit with Emacs

#+begin_src emacs-lisp

(use-package edit-server
  :commands edit-server-start
  :init (if after-init-time
              (edit-server-start)
            (add-hook 'after-init-hook
                      #'(lambda() (edit-server-start))))
  :config (setq edit-server-new-frame-alist
                '((name . "Edit with Emacs FRAME")
                  (top . 200)
                  (left . 200)
                  (width . 80)
                  (height . 25)
                  (minibuffer . t)
                  (menu-bar-lines . t)
                  (window-system . x))))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-edit-server"
#+end_src

* Dictionary
#+begin_src emacs-lisp
(global-set-key (kbd "C-c l") #'dictionary-lookup-definition)
#+end_src

* Hyperbole

#+begin_src emacs-lisp

(use-package hyperbole
  :config
  (hyperbole-mode 1))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-hyperbole"
#+end_src

* Org Mode

Set up Org Mode with a baseline configuration.  The following sections will add more things to it.

#+begin_src emacs-lisp

;; Turn on indentation and auto-fill mode for Org files
(defun pjp/org-mode-setup ()
  (org-indent-mode)
  (diminish org-indent-mode)
  (variable-pitch-mode 1)
  (auto-fill-mode 0)
  (setq org-src-window-setup 'current-window)
  )

(use-package org
  :defer t
  :hook (org-mode . pjp/org-mode-setup)
  :config
  (setq org-ellipsis " ▾"
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 2
        org-hide-block-startup nil
        org-src-preserve-indentation t
        org-startup-folded 'content
        org-descriptive-links nil
        org-cycle-separator-lines 2
        org-duration-format (quote h:mm))

  (setq org-refile-targets '((nil :maxlevel . 1)
                             (org-agenda-files :maxlevel . 1)))

  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-use-outline-path t)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((org . t)
     (emacs-lisp . t)
     (lisp . t)
     (shell . t)
     (python . t)
     (scheme . t)
     (plantuml . t)
     (gptel . t)))

  (setq org-babel-python-command "python3")
  (setq js-indent-level 2)

  (push '("conf-unix" . conf-unix) org-src-lang-modes)

  ;; NOTE: Subsequent sections are still part of this use-package block!

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-org"
"imagemagick"
"openjdk"
#+end_src

** Automatically "Tangle" on Save
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-auto-tangle-mode)
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-org-auto-tangle"
#+end_src

** Fonts and Bullets

Set the header font sizes to something more palatable.  A fair amount of inspiration has been taken from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this blog post]].

#+begin_src emacs-lisp

(dolist (face '((org-level-1 . 1.2)
                (org-level-2 . 1.1)
                (org-level-3 . 1.05)
                (org-level-4 . 1.0)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)))
  (set-face-attribute (car face) nil :font "Iosevka Aile" :weight 'regular :height (cdr face)))

;; Make sure org-indent face is available
(require 'org-indent)

;; Ensure that anything that should be fixed-pitch in Org files appears that way
(set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)

#+end_src

** Block Templates

These templates enable you to type things like =<el= and then hit =Tab= to expand
the template.  More documentation can be found at the Org Mode [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
documentation page.

#+begin_src emacs-lisp

;; This is needed as of Org 9.2
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src sh"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
(add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
(add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
(add-to-list 'org-structure-template-alist '("json" . "src json"))

#+end_src

** Org Roam

#+begin_src emacs-lisp

(use-package org-roam
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory (file-truename "~/Repositories/peter/org/roam"))
  (org-roam-completion-everywhere t)
  (org-roam-completion-system 'default)
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n g" . org-roam-graph)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n c" . org-roam-capture)
         ;; Dailies
         ("C-c n j" . org-roam-dailies-capture-today))
  :config
  (org-roam-db-autosync-mode)
  ;; If using org-roam-protocol
  (require 'org-roam-protocol))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-org-roam"
#+end_src

** End =use-package org-mode=

#+begin_src emacs-lisp

;; This ends the use-package org-mode block
)

#+end_src

** Exporting

#+begin_src emacs-lisp

(setq org-src-fontify-natively t
      org-src-tab-acts-natively t)

(setq org-descriptive-links nil)

(eval-after-load "org"
  '(require 'ox-org nil t))

(eval-after-load "org"
  '(require 'ox-md nil t))

(eval-after-load "org"
  '(require 'ox-gfm nil t))

(defun org-include-img-from-pdf (&rest _)
  "Convert pdf files to image files in org-mode bracket links.

                                                                         # ()convertfrompdf:t # This is a special comment; tells that the upcoming
                                                                                                                                                                # link points to the to-be-converted-to file.
                                                                         # If you have a foo.pdf that you need to convert to foo.png, use the
                                                                         # foo.png file name in the link.
                                                                         [[./foo.png]]
                                                         "
  (interactive)
  (if (executable-find "convert")
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\s-+()convertfrompdf\\s-*:\\s-*t"
                                  nil :noerror)
          ;; Keep on going to the next line till it finds a line with bracketed
          ;; file link.
          (while (progn
                   (forward-line 1)
                   (not (looking-at org-bracket-link-regexp))))
          ;; Get the sub-group 1 match, the link, from `org-bracket-link-regexp'
          (let ((link (match-string-no-properties 1)))
            (when (stringp link)
              (let* ((imgfile (expand-file-name link))
                     (pdffile (expand-file-name
                               (concat (file-name-sans-extension imgfile)
                                       "." "pdf")))
                     (cmd (concat "convert -density 96 -quality 85 "
                                  pdffile " " imgfile)))
                (when (and (file-readable-p pdffile)
                           (file-newer-than-file-p pdffile imgfile))
                  ;; This block is executed only if pdffile is newer than
                  ;; imgfile or if imgfile does not exist.
                  (shell-command cmd)
                  (message "%s" cmd)))))))
    (user-error "`convert' executable (part of Imagemagick) is not found")))

;; (defun my/org-include-img-from-pdf-before-save ()
;;   "Execute `org-include-img-from-pdf' just before saving the file."
;;     (add-hook 'before-save-hook #'org-include-img-from-pdf nil :local))
;; (add-hook 'org-mode-hook #'my/org-include-img-from-pdf-before-save)

;; If you want to attempt to auto-convert PDF to PNG  only during exports, and not during each save.
(with-eval-after-load 'ox
  (add-hook 'org-export-before-processing-hook #'org-include-img-from-pdf))

(defconst help/org-special-pre "^\s*#[+]")
(defun help/org-2every-src-block (fn)
  "Visit every Source-Block and evaluate `FN'."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t))
      (while (re-search-forward (concat help/org-special-pre "BEGIN_SRC") nil t)
        (let ((element (org-element-at-point)))
          (when (eq (org-element-type element) 'src-block)
            (funcall fn element)))))
    (save-buffer)))
;;(define-key org-mode-map (kbd "M-]") (lambda () (interactive)
;;                                                                                                                                                       (help/org-2every-src-block
;;                                                                                                                                                              'org-babel-remove-result)))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-ox-gfm"
#+end_src

** Latex

#+begin_src emacs-lisp


#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-auctex"
"emacs-cdlatex"
"texlive-scheme-basic"
"texlive-texinfo"
"texlive-adjustbox"
"texlive-booktabs"
"texlive-siunitx"
"texlive-geometry"
"texlive-graphics"
"texlive-wrapfig"
"texlive-ulem"
"texlive-capt-of"
"texlive-caption"
"texlive-advdate"
"texlive-beamer"
#+end_src

* Development
Configuration for various programming languages and dev tools that I use.

** Tree-sitter

#+begin_src emacs-lisp
;; Prefer Tree-sitter modes when available
(setq major-mode-remap-alist
      '((python-mode . python-ts-mode)
        (c-mode     . c-ts-mode)
        (c++-mode   . c++-ts-mode)
        (json-mode  . json-ts-mode)
        (css-mode   . css-ts-mode)
        (js-mode    . js-ts-mode)
        (js-json-mode . json-ts-mode)
        (sh-mode    . bash-ts-mode)))

;; Find Guix-provided grammars; never download at runtime.
(require 'seq)  ;; for seq-filter
(let* ((profiles (seq-filter #'identity
                             (list (getenv "GUIX_PROFILE")
                                   (expand-file-name "~/.guix-profile")
                                   (getenv "GUIX_ENVIRONMENT"))))
       (ts-dirs (mapcar (lambda (p) (expand-file-name "lib/tree-sitter" p)) profiles))
       (existing (seq-filter #'file-directory-p ts-dirs)))
  (setq treesit-extra-load-path (append existing treesit-extra-load-path)))

;; Better syntax highlighting & indentation with treesit
(setq treesit-font-lock-level 4)
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"tree-sitter"
"tree-sitter-bash"
"tree-sitter-c"
"tree-sitter-cpp"
"tree-sitter-css"
"tree-sitter-html"
"tree-sitter-javascript"
"tree-sitter-json"
"tree-sitter-python"
"tree-sitter-typescript"
#+end_src

** Git

*** Magit

https://magit.vc/manual/magit/

#+begin_src emacs-lisp

(use-package magit
  :commands (magit-status magit-get-current-branch)
  :diminish magit-auto-revert-mode
  :bind (("C-c g" . magit-status))
  :config
  (progn
    (setq magit-item-highlight-face 'bold))
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-magit"
#+end_src

*** magit-todos

This is an interesting extension to Magit that shows a TODOs section in your
git status buffer containing all lines with TODO (or other similar words) in
files contained within the repo.  More information at the [[https://github.com/alphapapa/magit-todos][GitHub repo]].

#+begin_src emacs-lisp

(use-package magit-todos
  :defer t)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-magit-todos"
#+end_src

*** Send e-mail for Git patches

OK, this isn't Emacs configuration, but it's relevant to development!

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"git"
"git:send-email"
#+end_src

** Project
#+begin_src emacs-lisp
(use-package project
  :bind-keymap
  ("C-c p" . project-prefix-map))
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-ggtags"
"universal-ctags"
"ripgrep"
"the-silver-searcher"
#+end_src

*** Project Configurations

This section contains project configurations for specific projects that I can't
drop a =.dir-locals.el= file into.  Documentation on this approach can be found in
the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Directory-Local-Variables.html][Emacs manual]].

#+begin_src emacs-lisp

#+end_src

** Languages

*** C/C++

#+begin_src emacs-lisp

(defun file-in-directory-list-p (file dirlist)
  "Returns true if the file specified is contained within one of
                                        the directories in the list. The directories must also exist."
  (let ((dirs (mapcar 'expand-file-name dirlist))
        (filedir (expand-file-name (file-name-directory file))))
    (and
     (file-directory-p filedir)
     (member-if (lambda (x) ; Check directory prefix matches
                  (string-match (substring x 0 (min(length filedir) (length x))) filedir))
                dirs))))

(defun buffer-standard-include-p ()
  "Returns true if the current buffer is contained within one of
                                        the directories in the INCLUDE environment variable."
  (and (getenv "INCLUDE")
       (file-in-directory-list-p buffer-file-name (split-string (getenv "INCLUDE") path-separator))))

(add-to-list 'magic-fallback-mode-alist '(buffer-standard-include-p . c++-mode))

;; function decides whether .h file is C or C++ header, sets C++ by
;; default because there's more chance of there being a .h without a
;; .cc than a .h without a .c (ie. for C++ template files)
(defun c-c++-header ()
  "sets either c-mode or c++-mode, whichever is appropriate for
                                        header"
  (interactive)
  (let ((c-file (concat (substring (buffer-file-name) 0 -1) "c")))
    (if (file-exists-p c-file)
        (c-mode)
      (c++-mode))))
(add-to-list 'auto-mode-alist '("\\.h\\'" . c-c++-header))
;; and if that doesn't work, a function to toggle between c-mode and
;; c++-mode
(defun c-c++-toggle ()
  "toggles between c-mode and c++-mode"
  (interactive)
  (cond ((string= major-mode "c-mode")
         (c++-mode))
        ((string= major-mode "c++-mode")
         (c-mode))))

(add-to-list 'auto-mode-alist '("\\.ino\\'" . c++-mode))

;; ROS style formatting
(defun ROS-c-mode-hook()
  (setq c-basic-offset 2)
  (setq indent-tabs-mode nil)
  (c-set-offset 'substatement-open 0)
  (c-set-offset 'innamespace 0)
  (c-set-offset 'case-label '+)
  (c-set-offset 'brace-list-open 0)
  (c-set-offset 'brace-list-intro '+)
  (c-set-offset 'brace-list-entry 0)
  (c-set-offset 'member-init-intro 0)
  (c-set-offset 'statement-case-open 0)
  (c-set-offset 'arglist-intro '+)
  (c-set-offset 'arglist-cont-nonempty '+)
  (c-set-offset 'arglist-close '+)
  (c-set-offset 'template-args-cont '+))
(add-hook 'c-mode-common-hook 'ROS-c-mode-hook)
#+end_src

*** Emacs Lisp

#+begin_src emacs-lisp
(electric-pair-mode 1)
(use-package paredit
  :config
  (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
  )
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-paredit"
#+end_src

*** Scheme

#+begin_src emacs-lisp

;; TODO: This causes issues for some reason.
;; :bind (:map geiser-mode-map
;;        ("TAB" . completion-at-point))

(use-package geiser
  :config
  ;; (setq geiser-default-implementation 'gambit)
  (setq geiser-default-implementation 'guile)
  (setq geiser-active-implementations '(guile))
  (setq geiser-implementations-alist '(((regexp "\\.scm$") guile))))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-geiser"
"emacs-geiser-guile"
#+end_src
*** Markdown

#+begin_src emacs-lisp

(use-package markdown-mode
  :mode "\\.md\\'"
  :config
  (setq markdown-command "marked")
  (defun pjp/set-markdown-header-font-sizes ()
    (dolist (face '((markdown-header-face-1 . 1.2)
                    (markdown-header-face-2 . 1.1)
                    (markdown-header-face-3 . 1.0)
                    (markdown-header-face-4 . 1.0)
                    (markdown-header-face-5 . 1.0)))
      (set-face-attribute (car face) nil :weight 'normal :height (cdr face))))

  (defun pjp/markdown-mode-hook ()
    (pjp/set-markdown-header-font-sizes))

  (add-hook 'markdown-mode-hook 'pjp/markdown-mode-hook))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-markdown-mode"
"emacs-markdown-preview-mode"
#+end_src

*** HTML

#+begin_src emacs-lisp

(use-package web-mode
  :mode "(\\.\\(html?\\|ejs\\|tsx\\|jsx\\)\\'"
  :config
  (setq-default web-mode-code-indent-offset 2)
  (setq-default web-mode-markup-indent-offset 2)
  (setq-default web-mode-attribute-indent-offset 2))

;; 1. Start the server with `httpd-start'
;; 2. Use `impatient-mode' on any buffer
;; (use-package impatient-mode)

;; (use-package skewer-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-web-mode"
#+end_src

*** YAML

#+begin_src emacs-lisp

(use-package yaml-mode
  :mode "\\.ya?ml\\'")

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-yaml-mode"
#+end_src

** Productivity

*** Snippets

#+begin_src emacs-lisp

(add-to-list 'yas-snippet-dirs
             "~/.config/emacs/snippets/guix")
(add-to-list 'yas-snippet-dirs
             "~/.config/emacs/snippets")
(yas-global-mode 1)

#+end_src

#+RESULTS:
: t

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-yasnippet"
"emacs-yasnippet-snippets"
#+end_src

*** Rainbow Delimiters

#+begin_src emacs-lisp

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-rainbow-delimiters"
#+end_src

*** Rainbow Mode

Sets the background of HTML color strings in buffers to be the color mentioned.

#+begin_src emacs-lisp

  (use-package rainbow-mode
    :defer t
    :hook (org-mode
           emacs-lisp-mode
           web-mode
           typescript-mode
           js2-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-rainbow-mode"
#+end_src

** Editing
*** CSV Files

#+begin_src emacs-lisp

(use-package csv)

(use-package csv-mode)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-csv"
"emacs-csv-mode"
#+end_src

** Code Formatting
*** string inflection

#+begin_src emacs-lisp

(use-package string-inflection
  :bind (("C-c c s"   . string-inflection-snake-case)
         ("C-c c p"   . string-inflection-pascal-case)
         ("C-c c c"   . string-inflection-camel-case)
         ("C-c c u"   . string-inflection-upcase)
         ("C-c c k"   . string-inflection-kebab-case)
         ("C-c c _"   . string-inflection-capital-snake-case)))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-string-inflection"
#+end_src

* Window Management
** Popper

#+begin_src emacs-lisp
(use-package popper
  :bind (("M-`"   . popper-toggle)
         ("C-`"   . popper-cycle)
         ("C-M-`" . popper-toggle-type))
  :init
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          ".*ChatGPT\\*"
          ".*GPTel\\*"
          "^magit:"
          help-mode
          helpful-mode
          compilation-mode))
  ;; Match eshell, shell, term and/or vterm buffers
  (setq popper-reference-buffers
        (append popper-reference-buffers
                '("^\\*eshell.*\\*$" eshell-mode ;eshell as a popup
                  "^\\*shell.*\\*$"  shell-mode  ;shell as a popup
                  "^\\*term.*\\*$"   term-mode   ;term as a popup
                  ;; "^\\*vterm.*\\*$"  vterm-mode  ;vterm as a popup
                  )))
  (popper-mode +1)
  (popper-echo-mode +1)
  :config
  (setq popper-group-function #'popper-group-by-directory)
)
#+end_src

**Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-popper"
#+end_src

** Control Buffer Placement

Emacs' default buffer placement algorithm is pretty disruptive if you like
setting up window layouts a certain way in your workflow. The
=display-buffer-alist= video controls this behavior and you can customize it to
prevent Emacs from popping up new windows when you run commands.

#+begin_src emacs-lisp

(setq display-buffer-base-action
      '(display-buffer-reuse-mode-window
        display-buffer-reuse-window
        display-buffer-same-window))

;; If a popup does happen, don't resize windows to be equal-sized
(setq even-window-sizes nil)

#+end_src

* Terminals

** vterm

[[https://github.com/akermu/emacs-libvterm/][vterm]] is an improved terminal emulator package which uses a compiled native
module to interact with the underlying terminal applications. This enables it
to be much faster than =term-mode= and to also provide a more complete
terminal emulation experience.

Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] installed before trying to
use =vterm= because there is a module that will need to be compiled before
you can use it successfully.

#+begin_src emacs-lisp

(use-package vterm
  :commands vterm
  :config
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
  ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
  (setq vterm-max-scrollback 10000)
  (add-hook
   'vterm-mode-hook
   (lambda() (setq show-trailing-whitespace nil)))
  :bind (:map vterm-mode-map
              ("M-n" . multi-vterm-next)
              ("M-p" . multi-vterm-prev)))

(use-package multi-vterm)
(global-set-key (kbd "C-c v") 'multi-vterm)
(global-set-key (kbd "C-c d") 'multi-vterm-dedicated-toggle)

(defun pjp/vterm-execute-region-or-current-line ()
  "Insert text of current line in vterm and execute."
  (interactive)
  (require 'vterm)
  (eval-when-compile (require 'subr-x))
  (let ((command (if (region-active-p)
                     (string-trim (buffer-substring
                                   (save-excursion (region-beginning))
                                   (save-excursion (region-end))))
                   (string-trim (buffer-substring (save-excursion
                                                    (beginning-of-line)
                                                    (point))
                                                  (save-excursion
                                                    (end-of-line)
                                                    (point)))))))
    (let ((buf (current-buffer)))
      (unless (get-buffer vterm-buffer-name)
        (vterm))
      (display-buffer vterm-buffer-name t)
      (switch-to-buffer-other-window vterm-buffer-name)
      (vterm--goto-line -1)
      (message command)
      (vterm-send-string command)
      (vterm-send-return)
      (switch-to-buffer-other-window buf)
      )))
(global-set-key (kbd "C-c x") 'pjp/vterm-execute-region-or-current-line)
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-vterm"
"emacs-multi-vterm"
"emacs-vterm-toggle"
#+end_src

** eshell

#+begin_src emacs-lisp

(defun pjp/configure-eshell ()
  ;; Save command history when commands are entered
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

  ;; Truncate buffer for performance
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

  (setq eshell-history-size         10000
        eshell-buffer-maximum-lines 10000
        eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t))

(use-package eshell
  :hook ((eshell-first-time-mode . pjp/configure-eshell)))

(use-package eshell-up)

(use-package eshell-toggle
  :custom
  (eshell-toggle-size-fraction 4)
  (eshell-toggle-run-command nil)
  :bind
  ("C-c s" . eshell-toggle))

(use-package eshell-syntax-highlighting
  :after eshell-mode
  :config
  ;; Enable in all Eshell buffers.
  (eshell-syntax-highlighting-global-mode +1))

(with-eval-after-load "esh-opt"
  (autoload 'epe-theme-multiline-with-status "eshell-prompt-extras")
  (setq eshell-highlight-prompt nil
        eshell-prompt-function 'epe-theme-multiline-with-status))

;; (with-eval-after-load "esh-opt"
;;   (require 'virtualenvwrapper)
;;   (venv-initialize-eshell)
;;   (autoload 'epe-theme-lambda "eshell-prompt-extras")
;;   (setq eshell-highlight-prompt nil
;;         eshell-prompt-function 'epe-theme-lambda))

;; (eshell-did-you-mean-setup)

(use-package eshell-bookmark
  :after eshell
  :config
  (add-hook 'eshell-mode-hook #'eshell-bookmark-setup))

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-eshell-up"
"emacs-eshell-toggle"
"emacs-eshell-syntax-highlighting"
"emacs-eshell-prompt-extras"
"emacs-eshell-did-you-mean"
"emacs-eshell-bookmark"
#+end_src

* Applications

** Email

#+begin_src emacs-lisp
;; Email entry point: load private config from a stable path, then open Mu4e.
(defun pjp/email ()
  (interactive)
  (let* ((home (or (getenv "HOME") (expand-file-name "~")))
         (xdg  (or (getenv "XDG_CONFIG_HOME")
                   (expand-file-name ".config" home)))
         (candidates (list
                      (expand-file-name "emacs/private/pjp-email.el" xdg)
                      (expand-file-name ".config/emacs/lisp/pjp-email.el" home)))
         (file (catch 'found
                 (dolist (f candidates)
                   (when (file-readable-p f) (throw 'found f)))
                 nil)))
    (unless file
      (user-error "Missing pjp-email.el (looked in %S)" candidates))
    (load file nil 'nomessage)
    (if (fboundp 'mu4e) (mu4e) (user-error "Mu4e not available; install Mu via Guix"))))
(keymap-global-set "C-c e" #'pjp/email)
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-mu4e-alert"
"emacs-org-mime"
#+end_src

** Arduino

#+begin_src emacs-lisp

(setq auto-mode-alist (cons '("\\.\\(pde\\|ino\\)$" . c++-mode) auto-mode-alist))

#+end_src

** PDF

#+begin_src emacs-lisp

(pdf-loader-install)

#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"emacs-pdf-tools"
#+end_src

** plantuml

#+begin_src emacs-lisp
(use-package plantuml-mode
  :config
  ;; Set plantuml-jar-path here, if not already set by another means
  ;; For example:
  (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))
  (add-to-list
   'org-src-lang-modes '("plantuml" . plantuml))
  (setq plantuml-indent-level 2)
  (setq plantuml-output-type "svg")
  ;; (setq plantuml-default-exec-mode 'executable)
  (setq plantuml-default-exec-mode 'jar)
  (add-hook 'org-mode-hook
            (lambda ()
              (setq org-plantuml-jar-path plantuml-jar-path)
              (setq org-plantuml-executable-path plantuml-executable-path)))

  )
;; (defun plantuml-preview-custom (bg-color)
;;   "Preview PlantUML in a new buffer with a specified background color."
;;   (interactive "sEnter background color (e.g., white, black): ")
;;   (let ((img (plantuml-preview)))
;;     (with-current-buffer (get-buffer-create "*PlantUML Preview*")
;;       (erase-buffer)
;;       (insert-image img)
;;       (setq-local background-color bg-color)
;;       (setq-local default-frame-alist `((background-color . ,bg-color)))
;;       (display-buffer (current-buffer)))))
;; (defun plantuml-preview-dual ()
;;   "Preview PlantUML in two buffers with different background colors."
;;   (interactive)
;;   (plantuml-preview-custom "white")
;;   (plantuml-preview-custom "black"))
#+end_src

*Guix Packages*

#+begin_src scheme :scheme guile :session guile :noweb-ref packages :noweb-sep ""
"plantuml"
"emacs-plantuml-mode"
#+end_src

* System Utilities
** Daemons

#+begin_src emacs-lisp

(use-package daemons
  :commands daemons)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-daemons"
#+end_src

** Docker

#+begin_src emacs-lisp

;; (use-package docker
;;   :commands docker)

;; (use-package docker-tramp
;;   :defer t
;;   :after docker)

(require 'dockerfile-mode)
(add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-dockerfile-mode"
#+end_src

* Development Environment

** buffer-env

#+begin_src emacs-lisp

(require 'inheritenv)
(add-hook 'hack-local-variables-hook 'buffer-env-update)

#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-buffer-env"
"emacs-inheritenv"
#+end_src

* System Crafters Settings

#+begin_src emacs-lisp

(recentf-mode 1)
(save-place-mode 1)
(setq use-dialog-box nil)

#+end_src

* Pandoc

#+begin_src emacs-lisp
(add-hook 'markdown-mode-hook 'pandoc-mode)
(eval-after-load "org"
  '(require 'ox-pandoc nil t))
(require 'org-pandoc-import)
(setq org-pandoc-import-options '((from . "markdown")
                                  (to . "org")))
;; (setq opi-transient-directory "/tmp")
;; (org-pandoc-import-transient-mode 1)
#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"pandoc"
"emacs-ox-pandoc"
"emacs-pandoc-mode"
"emacs-org-pandoc-import"
#+end_src

* Gptel

#+begin_src emacs-lisp
(use-package gptel
  :bind
  (("C-c a g" . gptel)
   ("C-c a RET" . gptel-send)
   ("C-c a r" . gptel-rewrite))
  :config
  (setq gptel-api-key-function
        (lambda (backend)
          (let* ((host (cond
                        ((string-prefix-p "openai" (symbol-name backend)) "api.openai.com")
                        ;; Add other backend hosts as needed
                        (t (error "Unknown backend for API key retrieval"))))
                 (key-path (format "api/%s" (car (split-string host "\\.")))))
            (password-store-get key-path))))
  ;; Other gptel configurations
  (setq gptel-default-mode 'org-mode)
  ;;   "Create dedicated output buffer for GPTel."
  ;;   (interactive)
  ;;   (get-buffer-create gptel-output-buffer)
  ;;   (switch-to-buffer gptel-output-buffer))
  ;; (my-gptel-create-output-buffer)

  ;; (setq gptel-default-mode 'org-mode
  ;;       gptel-expert-commands t
  ;;       gptel-track-media t
  ;;       gptel-include-reasoning 'ignore
  ;;       gptel-model 'gpt-4o
  ;;       gptel-log-level 'info
  ;;       gptel--debug nil)
  ;; (add-to-list 'gptel-prompt-prefix-alist `(org-mode . ,(concat "*** pjp " (format-time-string "[%Y-%m-%d]") "\n")))
  ;; (add-hook 'gptel-post-stream-hook 'gptel-auto-scroll)
  ;; (add-hook 'gptel-post-response-functions 'gptel-end-of-response)
  )

(use-package gptel-quick
  :bind
  ("C-c q" . gptel-quick))
#+end_src

*Guix Packages*

#+begin_src scheme :noweb-ref packages :noweb-sep ""
"emacs-gptel"
"emacs-ob-gptel"
"emacs-gptel-prompts"
"emacs-gptel-quick"
#+end_src

* Custom File
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./.config/emacs/custom.el :mkdirp yes :results silent
:END:

#+begin_src emacs-lisp
;;; custom.el --- Customized variables (empty stub) -*- lexical-binding: t; -*-
;; Emacs will write Customize changes to this file.
;; It is intentionally kept out of the reusable package.

;; Nothing here by default.

#+end_src

* Emacs Profile

*.config/guix/manifests/emacs.scm:*

#+begin_src scheme :scheme guile :session guile :tangle .config/guix/manifests/emacs.scm :noweb yes

(specifications->manifest
 '("emacs"
   <<packages>>
   ))

#+end_src
